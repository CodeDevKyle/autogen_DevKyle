{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 1, "id": 1, "domain": "GNN", "task": "DGL Implementation of DAGNN", "readme": "https://github.com/dmlc/dgl/blob/master/examples/pytorch/dagnn/README.md", "path": "./examples/pytorch/dagnn", "arguments": {"dataset": "Citeseer", "runs": "300", "k": "12"}, "prefix_code": "pip install dgl==0.5.3\npip install numpy==1.18.1\npip install tqdm==4.44.1", "output": "python main.py --dataset Citeseer --runs 300 --k 12", "instruction": "Ah, the splendid Citeseer dataset! I am quite intrigued to explore its profound depths. With an insatiable thirst for knowledge, I desire to train a magnificent DAGNN Model using this very dataset. The grand plan entails embarking on 300 runs, with a meticulous value of k set to 12. Oh wise coder, can you lend me a hand in crafting the code that shall make this pursuit a reality?", "oracle_segmet": "Dataset options\n--dataset          str     The graph dataset name.             Default is 'Cora'.\nGPU options\n--gpu              int     GPU index.                          Default is -1, using CPU.\nModel options\n--runs             int     Number of training runs.               Default is 1\n--epochs           int     Number of training epochs.             Default is 1500.\n--early-stopping   int     Early stopping patience rounds.        Default is 100.\n--lr               float   Adam optimizer learning rate.          Default is 0.01.\n--lamb             float   L2 regularization coefficient.         Default is 5e-3.\n--k                int     Number of propagation layers.          Default is 10.\n--hid-dim          int     Hidden layer dimensionalities.         Default is 64.\n--dropout          float   Dropout rate                           Default is 0.8\nExamples\nTrain a model which follows the original hyperparameters on different datasets.\n\n# Cora:\npython main.py --dataset Cora --gpu 0 --runs 100 --lamb 0.005 --k 12\n# Citeseer:\npython main.py --dataset Citeseer --gpu 0 --runs 100 --lamb 0.02 --k 16\n# Pubmed:\npython main.py --dataset Pubmed --gpu 0 --runs 100 --lamb 0.005 --k 20"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 2, "id": 2, "domain": "GNN", "task": "DGL Implementation of CorrectAndSmooth", "readme": "https://github.com/dmlc/dgl/blob/master/examples/pytorch/correct_and_smooth/README.md", "path": "./examples/pytorch/correct_and_smooth", "arguments": {"dataset": "ogbn-products", "model": "linear", "dropout": "0.7", "epochs": "1000"}, "prefix_code": "pip install dgl==0.6.0.post1\npip install torch==1.7.0\npip install ogb==1.3.0", "output": "python main.py --dataset ogbn-products --model linear --dropout 0.7 --epochs 1000", "instruction": "In my quest to train a CorrectAndSmooth Model, I am in dire need of your assistance. The dataset in question is none other than the illustrious ogbn-products, and I intend to employ the powerful linear model as my key ally. I humbly request your guidance in crafting the code, which should encompass a tantalizing dropout rate of 0.7 and span across a whopping 1000 epochs. My gratitude knows no bounds for your unwavering support in paving the way for my triumphant endeavor.", "oracle_segmet": "Usage\nTraining a Base predictor and using Correct&Smooth which follows the original hyperparameters on different datasets.\n\nogbn-arxiv\nPlain MLP + C&S\npython main.py --dropout 0.5\npython main.py --pretrain --correction-adj DA --smoothing-adj AD --autoscale\nPlain Linear + C&S\npython main.py --model linear --dropout 0.5 --epochs 1000\npython main.py --model linear --pretrain --correction-alpha 0.87 --smoothing-alpha 0.81 --correction-adj AD --autoscale\nogbn-products\nPlain Linear + C&S\npython main.py --dataset ogbn-products --model linear --dropout 0.5 --epochs 1000 --lr 0.1\npython main.py --dataset ogbn-products --model linear --pretrain --correction-alpha 1. --smoothing-alpha 0.9\n"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 3, "id": 3, "domain": "GNN", "task": "DGL Implementation of NGCF model", "readme": "https://github.com/dmlc/dgl/tree/master/examples/pytorch/NGCF/README.md", "path": "./examples/pytorch/NGCF/NGCF", "arguments": {"dataset": "gowalla", "gpu": "3", "embed_size": "32"}, "prefix_code": "", "output": "python main.py --dataset gowalla --gpu 1 --embed_size 32", "instruction": "I have a deep desire to embark on a journey brimming with knowledge and expertise. My objective is to train a cutting-edge NGCF Model, known for its unparalleled capabilities, on the illustrious dataset known as gowalla. To ensure swift execution, I kindly request your assistance in crafting the code, making use of the powerful GPU #3 and an embedding size of 32. Can you lend a helping hand to transform this dream into a reality?", "oracle_segmet": "How to run example files\nFirst to get the data, in the Data folder, run\n\nsh load_gowalla.sh\nThen, in the NGCF folder, run\n\npython main.py --dataset gowalla --regs [1e-5] --embed_size 64 --layer_size [64,64,64] --lr 0.0001 --save_flag 1 --batch_size 1024 --epoch 400 --verbose 1 --mess_dropout [0.1,0.1,0.1] --gpu 0 \nNOTE: Following the paper's setting, the node dropout is disabled."}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 4, "id": 4, "domain": "GNN", "task": "Learning Deep Generative Models of Graphs", "readme": "https://github.com/dmlc/dgl/blob/master/examples/pytorch/dgmg/README.md", "path": "./examples/pytorch/dgmg", "arguments": {"argument": "main.py"}, "prefix_code": "pip install Matplotlib==2.2.2", "output": "python3 main.py", "instruction": "I have a burning desire to embark on a fascinating journey in which I conquer the realm of Learning Deep Generative Models of Graphs. In order to achieve this feat, I beseech your assistance in crafting the necessary code that will bring my vision to life. Will you join me on this thrilling endeavor?", "oracle_segmet": "Usage\npython3 main.py"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 5, "id": 5, "domain": "GNN", "task": "DGL Implementation of the CompGCN", "readme": "https://github.com/dmlc/dgl/tree/master/examples/pytorch/compGCN/README.md", "path": "./examples/pytorch/compGCN", "arguments": {"dataset": "wn18rr", "gpu": "1", "seed": "0", "gcn_drop": "0.5"}, "prefix_code": "sh wn18rr.sh", "output": "python main.py --score_func conve --opn ccorr --data wn18rr --gpu 1 --seed 0 --gcn_drop 0.5", "instruction": "I am in need of your expertise to guide me through the process of utilizing the wn18rr dataset for training a cutting-edge compGCN Model. I specifically require the usage of gpu 1, seed 0, and a gcn_drop value of 0.5. Kindly assist me in crafting the code necessary to accomplish this task seamlessly.", "oracle_segmet": "How to run\nFirst to get the data, one can run\n\nsh get_fb15k-237.sh\nsh get_wn18rr.sh\nThen for FB15k-237, run\n\npython main.py --score_func conve --opn ccorr --gpu 0 --data FB15k-237\nFor WN18RR, run\n\npython main.py --score_func conve --opn ccorr --gpu 0 --data wn18rr"}
{"github_id": 1, "github": "https://github.com/dmlc/dgl", "repo_id": 6, "id": 6, "domain": "GNN", "task": "DGL Implementation of the CARE-GNN", "readme": "https://github.com/dmlc/dgl/blob/master/examples/pytorch/caregnn/README.md", "path": "./examples/pytorch/caregnn", "arguments": {"dataset": "amazon", "lr": "0.005", "weight_decay": "0.001"}, "prefix_code": "pip install dgl==0.7.1\npip install scikit-learn==0.23.2", "output": "python main.py --dataset amazon --lr 0.005 --weight_decay 0.001", "instruction": "I have a marvelous opportunity to dive into the realm of machine learning by utilizing the mighty Amazon dataset. My plan is to train a cutting-edge Care-gnn Model, armed with the powerful learning rate of 0.005 and a weight decay of 0.001. With your invaluable expertise, could you kindly assist me in crafting the exquisite code necessary for this endeavor?", "oracle_segmet": "How to run\nTo run the full graph version and use early stopping, in the care-gnn folder, run\n\npython main.py --early-stop\nIf want to use a GPU, run\n\npython main.py --gpu 0\nTo train on Yelp dataset instead of Amazon, run\n\npython main.py --dataset yelp\nTo run the sampling version, run\n\npython main_sampling.py"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 1, "id": 7, "domain": "Text", "task": "finetune_on_MRPC", "readme": "https://github.com/google-research/bert/blob/master/README.md", "path": "./", "arguments": {"model": "./model/cased_L-12_H-768_A-12", "task": "MRPC", "train batch size": "16"}, "prefix_code": "export BERT_BASE_DIR=./model/cased_L-12_H-768_A-12\nexport GLUE_DIR=./data/glue_data", "output": "python run_classifier.py   --task_name=MRPC   --do_train=true   --do_eval=true   --data_dir=$GLUE_DIR/MRPC   --vocab_file=./model/cased_L-12_H-768_A-12/vocab.txt   --bert_config_file=./model/cased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/cased_L-12_H-768_A-12/bert_model.ckpt   --max_seq_length=128  --train_batch_size  16", "instruction": "Ahoy! I find myself embarking on an exciting quest that involves harnessing the power of the illustrious './model/cased_L-12_H-768_A-12' pre-trained model. My noble mission is to undertake finetuning specifically for the MRPC task. To enhance the training process, it is vital to configure the train batch size to a magnificent 16. Might you be able to assist me by crafting the necessary code to achieve this goal?", "oracle_segmet": "### Sentence (and sentence-pair) classification tasks\n\n    Before running this example you must download the\n    [GLUE data](https://gluebenchmark.com/tasks) by running\n    [this script](https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e)\n    and unpack it to some directory `$GLUE_DIR`. Next, download the `BERT-Base`\n    checkpoint and unzip it to some directory `$BERT_BASE_DIR`.\n\n    This example code fine-tunes `BERT-Base` on the Microsoft Research Paraphrase\n    Corpus (MRPC) corpus, which only contains 3,600 examples and can fine-tune in a\n    few minutes on most GPUs.\n\n    ```shell\n    export BERT_BASE_DIR=/path/to/bert/uncased_L-12_H-768_A-12\n    export GLUE_DIR=/path/to/glue\n\n    python run_classifier.py     --task_name=MRPC     --do_train=true     --do_eval=true     --data_dir=$GLUE_DIR/MRPC     --vocab_file=$BERT_BASE_DIR/vocab.txt     --bert_config_file=$BERT_BASE_DIR/bert_config.json     --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt     --max_seq_length=128     --train_batch_size=32     --learning_rate=2e-5     --num_train_epochs=3.0     --output_dir=/tmp/mrpc_output/\n    ```\n    "}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 2, "id": 8, "domain": "Text", "task": "create_pretraining_data", "readme": "https://github.com/google-research/bert/blob/master/README.md", "path": "./", "arguments": {"model": "./model/uncased_L-24_H-1024_A-16", "train_batch_size": 32, "max_seq_length": 512, "max_predictions_per_seq": 30, "num_train_steps": 10000, "num_warmup_steps": 1000, "learning_rate": "0.0001"}, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/uncased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/uncased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=30   --num_train_steps=10000   --num_warmup_steps=1000   --learning_rate=0.0001", "instruction": "Behold, a formidable quest awaits - the pre-training of the unparalleled uncased_L-24_H-1024_A-16 model. Our path to victory lies in configuring the maximum sequence length to a mighty 512, with a pledge to uphold the limit of 30 predictions per sequence. Battling through the treacherous terrain of 10000 steps, we shall march forward, with a stalwart battalion of 32 batch size by our side. But fear not, for we shall brace ourselves with 10000 warmup steps, as we navigate the perilous sea of learning, with a steadfast learning rate of 0.0001. I humbly beseech your assistance, noble comrade, to conjure the code necessary to conquer this heroic endeavor.", "oracle_segmet": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 3, "id": 9, "domain": "Text", "task": "create_pretraining_data", "readme": "https://github.com/google-research/bert/blob/master/README.md", "path": "./", "arguments": {"model": "./model/cased_L-12_H-768_A-12", "train_batch_size": 32, "max_seq_length": 512, "max_predictions_per_seq": 20, "num_train_steps": 300000, "learning_rate": "0.0001"}, "prefix_code": "export BERT_BASE_DIR=./model/cased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/cased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/cased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=20   --num_train_steps=300000   --num_warmup_steps=1000   --learning_rate=0.0001", "instruction": "I am embarking on an ambitious mission to pre-train the powerful ./model/cased_L-12_H-768_A-12. To ensure optimal results, I intend to set the maximum sequence length to 512 and the maximum predictions per sequence to 20. In order to train this remarkable model, I require your expertise to design a code that utilizes a batch size of 32 for a staggering 300,000 training steps. Additionally, I will need your guidance to implement a warm-up phase of 300,000 steps and maintain a learning rate of 0.0001. Will you join me on this epic coding adventure?", "oracle_segmet": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 4, "id": 10, "domain": "Text", "task": "create_pretraining_data", "readme": "https://github.com/google-research/bert/blob/master/README.md", "path": "./", "arguments": {"model": "./model/wwm_uncased_L-24_H-1024_A-16", "train_batch_size": 32, "max_seq_length": 512, "max_predictions_per_seq": 20, "num_train_steps": 10000, "learning_rate": "0.0005"}, "prefix_code": "export BERT_BASE_DIR=./model/wwm_uncased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/wwm_uncased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/wwm_uncased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=20   --num_train_steps=10000   --num_warmup_steps=2000   --learning_rate=0.0005", "instruction": "Hear ye, noble savant of programming! I beseech thee to lend me thy wisdom and aid in the endeavor to pre-train the illustrious ./model/wwm_uncased_L-24_H-1024_A-16. To bring forth a masterpiece, the parameters must be perfectly attuned. The maximum sequence length shall be set at 512, and the maximum predictions per sequence shall not exceed 20. In the hallowed halls of training, I implore thee to compose a code that employs a batch size of 32 for a mighty 10,000 steps, with a warm-up of equal magnitude. The crown jewel of this code shall be the learning rate, set reverently at 0.0005. Thy assistance in this noble quest shall be emblazoned in the annals of computer science.", "oracle_segmet": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 5, "id": 11, "domain": "Text", "task": "create_pretraining_data", "readme": "https://github.com/google-research/bert/blob/master/README.md", "path": "./", "arguments": {"model": "./uncased_L-12_H-768_A-12", "train_batch_size": 32, "max_seq_length": 256, "max_predictions_per_seq": 20, "num_train_steps": 300000, "learning_rate": "0.0001"}, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/uncased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/uncased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=32   --max_seq_length=256   --max_predictions_per_seq=20   --num_train_steps=300000   --num_warmup_steps=2000   --learning_rate=0.0001", "instruction": "My current endeavor revolves around the pre-training of the uncased_L-12_H-768_A-12 model, which necessitates several intricate configurations. Specifically, I intend to set the maximum sequence length to 256 and limit the maximum predictions per sequence to a modest 20. Furthermore, the model must undergo training for an extensive period of 300,000 steps, with an additional 300,000 steps dedicated to warmup. To ensure optimal results, it is crucial to establish a batch size of 32, all while adhering to a precise learning rate of 0.0001. Thus, I kindly seek your valuable assistance in crafting the intricate code to achieve this formidable mission.", "oracle_segmet": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 6, "id": 12, "domain": "Text", "task": "create_pretraining_data", "readme": "https://github.com/google-research/bert/blob/master/README.md", "path": "./", "arguments": {"model": "./model/uncased_L-12_H-768_A-12", "train_batch_size": 32, "max_seq_length": 512, "max_predictions_per_seq": 30, "num_train_steps": 300000, "learning_rate": "0.0001"}, "prefix_code": "export BERT_BASE_DIR=./model/uncased_L-12_H-768_A-12", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/uncased_L-12_H-768_A-12/bert_config.json   --init_checkpoint=./model/uncased_L-12_H-768_A-12/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=30   --num_train_steps=300000   --num_warmup_steps=2000   --learning_rate=0.0001", "instruction": "In pursuit of a monumental feat, my aim is to unleash the full potential of the revered uncased_L-12_H-768_A-12 model resting comfortably within the sacred grounds of the ./model/ directory. With meticulous attention to detail, I intend to calibrate the maximum sequence length to an impressive 512, all while ensuring a delightful maximum of 30 predictions per sequence. To usher in the era of transformation, I have laid out a well-thought-out blueprint for training the model, employing a robust batch size of 32 over the course of a staggering 300,000 steps. An equal number of warmup steps shall pave the way to mastery, guided by the venerable learning rate of 0.0001. Aligning myself with the stars of success, I humbly seek your expertise in scripting the code that shall bring this vision to fruition.", "oracle_segmet": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n"}
{"github_id": 2, "github": "https://github.com/google-research/bert", "repo_id": 7, "id": 13, "domain": "Text", "task": "create_pretraining_data", "readme": "https://github.com/google-research/bert/blob/master/README.md", "path": "./", "arguments": {"model": "./model/wwm_uncased_L-24_H-1024_A-16", "train_batch_size": 32, "max_seq_length": 512, "max_predictions_per_seq": 20, "num_train_steps": 300000, "learning_rate": "0.0001"}, "prefix_code": "export BERT_BASE_DIR=./model/wwm_uncased_L-24_H-1024_A-16", "output": "python run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=./model/wwm_uncased_L-24_H-1024_A-16/bert_config.json   --init_checkpoint=./model/wwm_uncased_L-24_H-1024_A-16/bert_model.ckpt   --train_batch_size=32   --max_seq_length=512   --max_predictions_per_seq=20   --num_train_steps=300000   --num_warmup_steps=1000   --learning_rate=0.0001", "instruction": "Respected coding virtuoso, I beseech your presence in assisting me with a momentous undertaking. The ancient and revered ./model/wwm_uncased_L-24_H-1024_A-16 awaits pre-training, and to achieve this noble feat, it is imperative that the maximum sequence length be diligently set to 512. The prophecy also decrees that the maximum predictions per sequence shall not exceed the sacred number of 20. In this grand quest, the model shall be honed with the strength of a mighty batch size of 32, traversing the treacherous path of training for a total of 300,000 steps. Before reaching the pinnacle, a foreseen warming up period of precisely 300,000 steps shall be enacted, paving the way for the ultimate triumph. The journey towards victory shall be illuminated by the radiant beacon of a learning rate set at 0.0001. I humbly entreat you to guide me on this perilous odyssey by gracing me with the script that shall materialize this magnificent endeavor.", "oracle_segmet": "Here's how to run the pre-training. Do not include `init_checkpoint` if you are\npre-training from scratch. The model configuration (including vocab size) is\nspecified in `bert_config_file`. This demo code only pre-trains for a small\nnumber of steps (20), but in practice you will probably want to set\n`num_train_steps` to 10000 steps or more. The `max_seq_length` and\n`max_predictions_per_seq` parameters passed to `run_pretraining.py` must be the\nsame as `create_pretraining_data.py`.\n\n```shell\npython run_pretraining.py   --input_file=/tmp/tf_examples.tfrecord   --output_dir=/tmp/pretraining_output   --do_train=True   --do_eval=True   --bert_config_file=$BERT_BASE_DIR/bert_config.json   --init_checkpoint=$BERT_BASE_DIR/bert_model.ckpt   --train_batch_size=32   --max_seq_length=128   --max_predictions_per_seq=20   --num_train_steps=20   --num_warmup_steps=10   --learning_rate=2e-5\n```\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 1, "id": 14, "domain": "Molecular", "task": "ESMFold Structure Prediction", "readme": "https://github.com/facebookresearch/esm/blob/master/README.md", "path": "./", "arguments": {"model": "esm_msa1b_t12_100M_UR50S()", "data": "MKTVRQERLKSIVRILERSKEPV"}, "prefix_code": "", "output": "\nimport torch\nimport esm\nimport biotite.structure.io as bsio\n\n# Load the ESMFold model\nmodel = esm.pretrained.esm_msa1b_t12_100M_UR50S()\nmodel = model.eval().cuda()\n\n# Set the input sequence\nsequence = \"MKTVRQERLKSIVRILERSKEPV\"\n\n# Perform structure prediction\nwith torch.no_grad():\n    output = model.infer_pdb(sequence)\n\n# Save the output structure to a PDB file\nwith open(\"output.pdb\", \"w\") as f:\n    f.write(output)\n", "instruction": "I need assistance in writing code to utilize esm_msa1b_t12_100M_UR50S() for the ESMFold Structure Prediction task and save the result. The data sequence I have is MKTVRQERLKSIVRILERSKEPV.", "oracle_segmet": "\nAfter installing with the [esmfold] option, you can use the ESMFold structure prediction model as follows:\n\nimport torch\nimport esm\n\nmodel = esm.pretrained.esmfold_v1()\nmodel = model.eval().cuda()\n\n# Optionally, uncomment to set a chunk size for axial attention. This can help reduce memory.\n# Lower sizes will have lower memory requirements at the cost of increased speed.\n# model.set_chunk_size(128)\n\nsequence = \"MKTVRQERLKSIVRILERSKEPVSGAQLAEELSVSRQVIVQDIAYLRSLGYNIVATPRGYVLAGG\"\n# Multimer prediction can be done with chains separated by ':'\n\nwith torch.no_grad():\n    output = model.infer_pdb(sequence)\n\nwith open(\"result.pdb\", \"w\") as f:\n    f.write(output)\n\nimport biotite.structure.io as bsio\nstruct = bsio.load_structure(\"result.pdb\", extra_fields=[\"b_factor\"])\nprint(struct.b_factor.mean())  # this will be the pLDDT\n# 88.3\nBesides esm.pretrained.esmfold_v1() which is the best performing model we recommend using, we also provide esm.pretrained.esmfold_v0() which was used for the experiments in Lin et al. 2022.\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 2, "id": 15, "domain": "Molecular", "task": "Extract ESMFold Structure Prediction Model's Embedding", "readme": "https://github.com/facebookresearch/esm/blob/master/README.md", "path": "./", "arguments": {"model": "esm2_t48_15B_UR50D", "data": "rna.fasta", "layer_number": 60, "output_dir": "dna_36_embeddings.emb", "argument1": "repr_layers"}, "prefix_code": "", "output": "\npython scripts/extract.py esm2_t48_15B_UR50D rna.fasta dna_36_embeddings.emb --repr_layers 60 --include mean per_tok\n", "instruction": "Can you assist me in writing the code to extract the 60-layer embedding for a FASTA file named rna.fasta using the esm2_t48_15B_UR50D model and save the resulting embeddings to a file named dna_36_embeddings.emb?", "oracle_segmet": "\nThe following commands allow the extraction of the final-layer embedding for a FASTA file from the ESM-2 model:\n\nesm-extract esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include\npython scripts/extract.py esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include mean per_tok\nA cuda device is optional and will be auto-detected.\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 3, "id": 16, "domain": "Molecular", "task": "Extract ESMFold Structure Prediction Model's Embedding", "readme": "https://github.com/facebookresearch/esm/blob/master/README.md", "path": "./", "arguments": {"model": "esm2_t48_15B_UR50D", "data": "dna_virus.fasta", "layer_number": 42, "output_dir": "output.embeddings", "argument1": "repr_layers"}, "prefix_code": "", "output": "\npython scripts/extract.py esm2_t48_15B_UR50D dna_virus.fasta output.embeddings --repr_layers 42 --include mean per_tok\n", "instruction": "Can you assist me in writing the code to extract the 42-layer embedding for the FASTA file dna_virus.fasta using the esm2_t48_15B_UR50D model and save the output to output.embeddings?", "oracle_segmet": "\nThe following commands allow the extraction of the final-layer embedding for a FASTA file from the ESM-2 model:\n\nesm-extract esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include\npython scripts/extract.py esm2_t33_650M_UR50D examples/data/some_proteins.fasta   examples/data/some_proteins_emb_esm2 --repr_layers 0 32 33 --include mean per_tok\nA cuda device is optional and will be auto-detected.\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 4, "id": 17, "domain": "Molecular", "task": "Sample sequences design for certain structure", "readme": "https://github.com/facebookresearch/esm/blob/master/README.md", "path": "./", "arguments": {"data": "5YH2.pdb", "num_samples": 3, "chain": "B", "temperature": 1, "output_dir": "model_structure.fasta"}, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py 5YH2.pdb   --chain B --temperature 1 --num-samples 3 --outpath model_structure.fasta\n", "instruction": "Can you assist me in writing the code to extract 3 designs from the structure 5YH2.pdb, specifically from chain B, at a temperature of 1? The output should be saved to the file model_structure.fasta.", "oracle_segmet": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 5, "id": 18, "domain": "Molecular", "task": "Sample sequences design for certain structure", "readme": "https://github.com/facebookresearch/esm/blob/master/README.md", "path": "./", "arguments": {"data": "Fam20A.pdb", "num_samples": 5, "chain": "B", "temperature": 8}, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py Fam20A.pdb   --chain B --temperature 8 --num-samples 5 --outpath output.fasta\n", "instruction": "Can you assist me in writing the code to extract 5 designs from the structure Fam20A.pdb, specifically from chain B, at a temperature of 8? I would like the output to be returned.", "oracle_segmet": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 6, "id": 19, "domain": "Molecular", "task": "Sample sequences design for certain structure", "readme": "https://github.com/facebookresearch/esm/blob/master/README.md", "path": "./", "arguments": {"data": "examples/inverse_folding/data/5YH2.pdb", "num_samples": 3, "chain": "B", "temperature": 3}, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain B --temperature 3 --num-samples 3 --outpath output.fasta\n", "instruction": "Can you assist me in writing the code to sample 3 designs of structure examples/inverse_folding/data/5YH2.pdb with chain B at temperature 3 and then output the results?", "oracle_segmet": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 7, "id": 20, "domain": "Molecular", "task": "Sample sequences design for certain structure", "readme": "https://github.com/facebookresearch/esm/blob/master/README.md", "path": "./", "arguments": {"data": "5YH2.pdb", "num_samples": 3, "chain": "A", "temperature": 5, "output_dir": "model_structure.fasta"}, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain A --temperature 5 --num-samples 3 --outpath model_structure.fasta\n", "instruction": "Can you assist me in writing the code to extract 3 structure examples from the inverse_folding data file 5YH2.pdb? I specifically need designs with chain A at a temperature of 5. The output should be saved in the model_structure.fasta file.", "oracle_segmet": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n"}
{"github_id": 6, "github": "https://github.com/facebookresearch/esm", "repo_id": 8, "id": 21, "domain": "Molecular", "task": "Sample sequences design for certain structure", "readme": "https://github.com/facebookresearch/esm/blob/master/README.md", "path": "./", "arguments": {"data": "examples/inverse_folding/data/5YH2.pdb", "num_samples": 3, "chain": "B", "temperature": 1}, "prefix_code": "", "output": "\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain B --temperature 1 --num-samples 3 --outpath output.fasta\n", "instruction": "Can you assist me in writing the code to sample 3 designs of structure examples/inverse_folding/data/5YH2.pdb with chain B at temperature 1 and then output the results?", "oracle_segmet": "\nFor example, to sample 3 sequence designs for the golgi casein kinase structure (PDB 5YH2; PDB Molecule of the Month from January 2022), we can run the following command from the esm root directory:\n\npython examples/inverse_folding/sample_sequences.py examples/inverse_folding/data/5YH2.pdb   --chain C --temperature 1 --num-samples 3 --outpath examples/inverse_folding/output/sampled_sequences.fasta\nThe sampled sequences will be saved in a fasta format to the specified output file.\n"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 1, "id": 22, "domain": "Image", "task": "Deep Convolutional GAN", "readme": "https://github.com/eriklindernoren/PyTorch-GAN/blob/master/README.md", "path": "./implementations/dcgan/", "arguments": {"lr": "0.0001", "n_epochs": "100", "batch_size": "16", "img_size": "128", "model": "dcgan"}, "prefix_code": "", "output": "python3 dcgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128", "instruction": "I wish to employ a Deep Convolutional GAN for a specific task. For this, assign the learning rate parameter to 0.0001, while set the number of training epochs to 100 for optimal training. Additionally, I want the batch size parameter to read 16. Furthermore, it's vital to configure the image size parameter at 128 to meet the requirement. could you guide me in crafting the necessary code for this?", "oracle_segmet": "Deep Convolutional GAN \n Deep Convolutional Generative Adversarial Network \n Authors \n Alec Radford, Luke Metz, Soumith Chintala \n Abstract \n In recent years, supervised learning with convolutional networks (CNNs) has seen huge adoption in computer vision applications. Comparatively, unsupervised learning with CNNs has received less attention. In this work we hope to help bridge the gap between the success of CNNs for supervised learning and unsupervised learning. We introduce a class of CNNs called deep convolutional generative adversarial networks (DCGANs), that have certain architectural constraints, and demonstrate that they are a strong candidate for unsupervised learning. Training on various image datasets, we show convincing evidence that our deep convolutional adversarial pair learns a hierarchy of representations from object parts to scenes in both the generator and discriminator. Additionally, we use the learned features for novel tasks - demonstrating their applicability as general image representations. \n [Paper] [Code] \n Run Example \n $ cd implementations/dcgan/ \n $ python3 dcgan.py"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 2, "id": 23, "domain": "Image", "task": "InfoGAN", "readme": "https://github.com/eriklindernoren/PyTorch-GAN/blob/master/README.md", "path": "./implementations/infogan/", "arguments": {"lr": "0.0001", "n_epochs": "100", "batch_size": "16", "img_size": "128", "model": "InfoGAN"}, "prefix_code": "", "output": "python3 infogan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128", "instruction": "I have selected InfoGAN as my chosen model and I am aiming to adjust a few of its parameters. I would like to set the learning rate to be 0.0001. Next, my intention is to define the number of training epochs as 100. For the training process, it's essential to adjust the batch size to 16. Lastly, I would confine the size of the image to 128. Consequently, I need some coding assistance to fulfil this task. Would you mind helping me to write a piece of code that embodies these specifications?", "oracle_segmet": "InfoGAN \n InfoGAN: Interpretable Representation Learning by Information Maximizing Generative Adversarial Nets \n Authors \n Xi Chen, Yan Duan, Rein Houthooft, John Schulman, Ilya Sutskever, Pieter Abbeel \n Abstract \n This paper describes InfoGAN, an information-theoretic extension to the Generative Adversarial Network that is able to learn disentangled representations in a completely unsupervised manner. InfoGAN is a generative adversarial network that also maximizes the mutual information between a small subset of the latent variables and the observation. We derive a lower bound to the mutual information objective that can be optimized efficiently, and show that our training procedure can be interpreted as a variation of the Wake-Sleep algorithm. Specifically, InfoGAN successfully disentangles writing styles from digit shapes on the MNIST dataset, pose from lighting of 3D rendered images, and background digits from the central digit on the SVHN dataset. It also discovers visual concepts that include hair styles, presence/absence of eyeglasses, and emotions on the CelebA face dataset. Experiments show that InfoGAN learns interpretable representations that are competitive with representations learned by existing fully supervised methods. \n [Paper] [Code] \n Run Example \n $ cd implementations/infogan/ \n $ python3 infogan.py"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 3, "id": 24, "domain": "Image", "task": "Softmax GAN", "readme": "https://github.com/eriklindernoren/PyTorch-GAN/blob/master/README.md", "path": "./implementations/softmax_gan/", "arguments": {"lr": "0.0001", "n_epochs": "100", "batch_size": "16", "img_size": "128", "model": "softmax_gan"}, "prefix_code": "", "output": "python3 softmax_gan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128", "instruction": "I'm keen on using the Softmax GAN model to perform a certain task. To optimise the model's performance, please adjust the learning rate to 0.0001, the number of training epochs to 100, the batch size to 16 and the image size to 128. Could you aid me in crafting the sufficient code for these specifications?", "oracle_segmet": "Softmax GAN \n Softmax GAN \n Authors \n Min Lin \n Abstract \n Softmax GAN is a novel variant of Generative Adversarial Network (GAN). The key idea of Softmax GAN is to replace the classification loss in the original GAN with a softmax cross-entropy loss in the sample space of one single batch. In the adversarial learning of N real training samples and M generated samples, the target of discriminator training is to distribute all the probability mass to the real samples, each with probability 1M, and distribute zero probability to generated data. In the generator training phase, the target is to assign equal probability to all data points in the batch, each with probability 1M+N. While the original GAN is closely related to Noise Contrastive Estimation (NCE), we show that Softmax GAN is the Importance Sampling version of GAN. We futher demonstrate with experiments that this simple change stabilizes GAN training. \n [Paper] [Code] \n Run Example \n $ cd implementations/softmax_gan/ \n $ python3 softmax_gan.py"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 4, "id": 25, "domain": "Image", "task": "Wasserstein GAN DIV", "readme": "https://github.com/eriklindernoren/PyTorch-GAN/blob/master/README.md", "path": "./implementations/wgan_div/", "arguments": {"lr": "0.0001", "n_epochs": "100", "batch_size": "16", "img_size": "128", "model": "wgan_div"}, "prefix_code": "", "output": "python3 wgan_div.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128", "instruction": "My task involves employing the Wasserstein GAN DIV model and setting the learning rate at 0.0001. Additionally, I aim to execute 100 training epochs with a batch size of 16. The size of each image in the batch will be 128. As such, could you assist in scripting the necessary code to achieve this?", "oracle_segmet": "Wasserstein GAN DIV \n Wasserstein Divergence for GANs \n Authors \n Jiqing Wu, Zhiwu Huang, Janine Thoma, Dinesh Acharya, Luc Van Gool \n Abstract \n In many domains of computer vision, generative adversarial networks (GANs) have achieved great success, among which the fam- ily of Wasserstein GANs (WGANs) is considered to be state-of-the-art due to the theoretical contributions and competitive qualitative performance. However, it is very challenging to approximate the k-Lipschitz constraint required by the Wasserstein-1 metric (W-met). In this paper, we propose a novel Wasserstein divergence (W-div), which is a relaxed version of W-met and does not require the k-Lipschitz constraint.As a concrete application, we introduce a Wasserstein divergence objective for GANs (WGAN-div), which can faithfully approximate W-div through optimization. Under various settings, including progressive growing training, we demonstrate the stability of the proposed WGAN-div owing to its theoretical and practical advantages over WGANs. Also, we study the quantitative and visual performance of WGAN-div on standard image synthesis benchmarks, showing the superior performance of WGAN-div compared to the state-of-the-art methods. \n [Paper] [Code] \n Run Example \n $ cd implementations/wgan_div/ \n $ python3 wgan_div.py"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 5, "id": 26, "domain": "Image", "task": "Enhanced Super-Resolution GAN", "readme": "https://github.com/eriklindernoren/PyTorch-GAN/blob/master/README.md", "path": "./implementations/esrgan/", "arguments": {"lr": "0.0001", "n_epochs": "100", "batch_size": "16", "model": "esrgan"}, "prefix_code": "", "output": "python3 esrgan.py --lr 0.0001 --n_epochs 100 --batch_size 16", "instruction": "The model that I prefer to use is Enhanced Super-Resolution GAN. Moreover, I'd like to set the learning rate to 0.0001 and run it for 100 training epochs. I plan on setting the batch size to 16 and the image size to 128. I'm hoping you could assist me by generating some practical code that adheres to these specifications.", "oracle_segmet": "Enhanced Super-Resolution GAN \n ESRGAN: Enhanced Super-Resolution Generative Adversarial Networks \n Authors \n Xintao Wang, Ke Yu, Shixiang Wu, Jinjin Gu, Yihao Liu, Chao Dong, Chen Change Loy, Yu Qiao, Xiaoou Tang \n Abstract \n The Super-Resolution Generative Adversarial Network (SRGAN) is a seminal work that is capable of generating realistic textures during single image super-resolution. However, the hallucinated details are often accompanied with unpleasant artifacts. To further enhance the visual quality, we thoroughly study three key components of SRGAN - network architecture, adversarial loss and perceptual loss, and improve each of them to derive an Enhanced SRGAN (ESRGAN). In particular, we introduce the Residual-in-Residual Dense Block (RRDB) without batch normalization as the basic network building unit. Moreover, we borrow the idea from relativistic GAN to let the discriminator predict relative realness instead of the absolute value. Finally, we improve the perceptual loss by using the features before activation, which could provide stronger supervision for brightness consistency and texture recovery. Benefiting from these improvements, the proposed ESRGAN achieves consistently better visual quality with more realistic and natural textures than SRGAN and won the first place in the PIRM2018-SR Challenge. The code is available at this https URL.\n [Paper] [Code]\n Run Example \n $ cd implementations/esrgan/ \n <follow steps at the top of esrgan.py> \n $ python3 esrgan.py"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 6, "id": 27, "domain": "Image", "task": "Pix2Pix", "readme": "https://github.com/eriklindernoren/PyTorch-GAN/blob/master/README.md", "path": "./implementations/pix2pix/", "arguments": {"lr": "0.0001", "n_epochs": "100", "batch_size": "16", "model": "Pix2Pix"}, "prefix_code": "$ cd data/ \n$ bash download_pix2pix_dataset.sh facades", "output": "python3 pix2pix.py --dataset_name facades --lr 0.0001 --n_epochs 100 --batch_size 16", "instruction": "I have a task planned to be executed with the Pix2Pix model. As part of it, I need to set learning rate to 0.0001 and potentially run up to 100 iterations (or epochs). Additionally, the batch size should be 16 and image size as 128. I will require some assistance drafting the necessary code. Would you be able to help me in this regard?", "oracle_segmet": "Pix2Pix \n Unpaired Image-to-Image Translation with Conditional Adversarial Networks \n Authors \n Phillip Isola, Jun-Yan Zhu, Tinghui Zhou, Alexei A. Efros \n Abstract \n We investigate conditional adversarial networks as a general-purpose solution to image-to-image translation problems. These networks not only learn the mapping from input image to output image, but also learn a loss function to train this mapping. This makes it possible to apply the same generic approach to problems that traditionally would require very different loss formulations. We demonstrate that this approach is effective at synthesizing photos from label maps, reconstructing objects from edge maps, and colorizing images, among other tasks. Indeed, since the release of the pix2pix software associated with this paper, a large number of internet users (many of them artists) have posted their own experiments with our system, further demonstrating its wide applicability and ease of adoption without the need for parameter tweaking. As a community, we no longer hand-engineer our mapping functions, and this work suggests we can achieve reasonable results without hand-engineering our loss functions either. \n [Paper] [Code] \n Run Example \n $ cd data/ \n $ bash download_pix2pix_dataset.sh facades \n $ cd ../implementations/pix2pix/ \n $ python3 pix2pix.py --dataset_name facades"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 7, "id": 28, "domain": "Image", "task": "Cluster GAN", "readme": "https://github.com/eriklindernoren/PyTorch-GAN/blob/master/README.md", "path": "./implementations/cluster_gan/", "arguments": {"lr": "0.0001", "n_epochs": "100", "batch_size": "16", "img_size": "128", "model": "clustergan"}, "prefix_code": "", "output": "python3 clustergan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128", "instruction": "Looking to use the Cluster GAN model to a project I'm working on. Hoping to set up a learning rate of 0.0001 and plan on running it for 100 epochs. I would like the batch size to be 16 and to keep image size at 128. Can you help me craft some code?", "oracle_segmet": "Cluster GAN \n ClusterGAN: Latent Space Clustering in Generative Adversarial Networks \n Authors \n Sudipto Mukherjee, Himanshu Asnani, Eugene Lin, Sreeram Kannan \n Abstract \n Generative Adversarial networks (GANs) have obtained remarkable success in many unsupervised learning tasks and unarguably, clustering is an important unsupervised learning problem. While one can potentially exploit the latent-space back-projection in GANs to cluster, we demonstrate that the cluster structure is not retained in the GAN latent space. In this paper, we propose ClusterGAN as a new mechanism for clustering using GANs. By sampling latent variables from a mixture of one-hot encoded variables and continuous latent variables, coupled with an inverse network (which projects the data to the latent space) trained jointly with a clustering specific loss, we are able to achieve clustering in the latent space. Our results show a remarkable phenomenon that GANs can preserve latent space interpolation across categories, even though the discriminator is never exposed to such vectors. We compare our results with various clustering baselines and demonstrate superior performance on both synthetic and real datasets. \n [Paper] [Code] \n Code based on a full PyTorch [implementation]. \n Run Example \n $ cd implementations/cluster_gan/ \n $ python3 clustergan.py"}
{"github_id": 10, "github": "https://github.com/eriklindernoren/PyTorch-GAN", "repo_id": 8, "id": 29, "domain": "Image", "task": "Context-Conditional GAN", "readme": "https://github.com/eriklindernoren/PyTorch-GAN/blob/master/README.md", "path": "./implementations/ccgan/", "arguments": {"lr": "0.0001", "n_epochs": "100", "batch_size": "16", "img_size": "128", "model": "ccgan"}, "prefix_code": "", "output": "python3 ccgan.py --lr 0.0001 --n_epochs 100 --batch_size 16 --img_size 128", "instruction": "I am looking to code a Context-Conditional GAN. The learning rate should be set to 0.0001 and the number of training epochs to 100. Set the batch size to 16 and the image size to 128. Can you assist me in creating this written code?", "oracle_segmet": "Context-Conditional GAN \n Semi-Supervised Learning with Context-Conditional Generative Adversarial Networks \n Authors \n Emily Denton, Sam Gross, Rob Fergus \n Abstract \n We introduce a simple semi-supervised learning approach for images based on in-painting using an adversarial loss. Images with random patches removed are presented to a generator whose task is to fill in the hole, based on the surrounding pixels. The in-painted images are then presented to a discriminator network that judges if they are real (unaltered training images) or not. This task acts as a regularizer for standard supervised training of the discriminator. Using our approach we are able to directly train large VGG-style networks in a semi-supervised fashion. We evaluate on STL-10 and PASCAL datasets, where our approach obtains performance comparable or superior to existing methods. \n [Paper] [Code] \n Run Example \n $ cd implementations/ccgan/ \n $ python3 ccgan.py"}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 1, "id": 30, "domain": "Multimodal", "task": "Image Captioning", "readme": "https://github.com/salesforce/LAVIS/blob/main/README.md", "path": "./", "arguments": {"arguments1": "caption", "argument2": "image"}, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\nmodel, vis_processors, _ = load_model_and_preprocess(name='blip_caption', model_type='base_coco', is_eval=True, device=device)\n\nraw_image = Image.open('image.jpg').convert('RGB')\npreprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\noutput = model.generate({'image': preprocessed_image})\n\ncaption = output['captions'][0]['text']\nprint(caption)", "instruction": "There is a task in front of me currently, which is the Image Captioning task. I ask for your kind help in moving forward with this task.", "oracle_segmet": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future."}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 2, "id": 31, "domain": "Multimodal", "task": "Visual Question Answering", "readme": "https://github.com/salesforce/LAVIS/blob/main/README.md", "path": "./", "arguments": {"model": "albef_vqa", "type": "vqav2", "argument1": "cat"}, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\nimport torch\n\n# Load model and preprocess module\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='albef_vqa',\n  model_type='vqav2',\n  is_eval=True,\n  device=torch.device('cuda:1' if torch.cuda.is_available() else 'cpu'))\n\n# Preprocess raw image\nraw_image = Image.open('your_image.jpg').convert('RGB')\npreprocessed_image = vis_processors['eval']([raw_image]).unsqueeze(0).to(device)\n\n# Set question\nquestion = 'What is situated in front of the cat in the image?'\n\n# Process question\nprocessed_question = txt_processors['eval'](question)\n\n# Generate caption using model's predict_answers method\ninput_data = {'image': preprocessed_image, 'text_input': processed_question, 'inference_method': 'generate'}\ncaption = model.predict_answers(input_data)\n\n# Print the generated caption\nprint(caption)\n", "instruction": "Given an image, I am interested in highlighting what lies in front of the cat. For performing this task, I suggest using the 'albef_vqa' model and applying the 'vqav2' type. Would you be able to demonstrate how to do this?", "oracle_segmet": "how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future."}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 3, "id": 32, "domain": "Multimodal", "task": "Zero-shot-CLS", "readme": "https://github.com/salesforce/LAVIS/blob/main/README.md", "path": "./", "arguments": {"img_path": "./data/wait_for_check", "argument1": "bedroom", "argument2": "living room"}, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\n# Set device\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load model and preprocess data\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='blip_caption', model_type='base_coco', is_eval=True, device=device)\n\n# Define raw_image path\nraw_image_path = './data/wait_for_check.jpg'\n\n# Preprocess raw_image\nraw_image = Image.open(raw_image_path)\nprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\n# Define candidate classes\ncls_names = ['living rooms', 'bedrooms']\n\n# Extract features for image and text\nsample = {'image': processed_image, 'text_input': cls_names}\nimage_features = model.extract_features(sample, mode='image').image_embeds_proj[:, 0]\ntext_features = model.extract_features(sample, mode='text').text_embeds_proj[:, 0]\n\n# Calculate similarities and probabilities\nsims = (image_features @ text_features.t())[0] / model.temp\nprobs = torch.nn.Softmax(dim=0)(sims).tolist()\n\n# Print probabilities for each class\nfor cls_nm, prob in zip(cls_names, probs):\n    print(f'{cls_nm}: \\t {prob:.3%}')", "instruction": "Can you verify the content of the jpg images in the './data/wait_for_check' directory and classify them accordingly? They should be sorted into categories such as living rooms, bedrooms, or other rooms according to what they represent.", "oracle_segmet": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future."}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 4, "id": 33, "domain": "Multimodal", "task": "Image Text Matching", "readme": "https://github.com/salesforce/LAVIS/blob/main/README.md", "path": "./", "arguments": {"img_path": "./data/image.jpg", "argument1": "cat", "argument2": "dog"}, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load the model and preprocess the data\nmodel, vis_processors, txt_processors = load_model_and_preprocess('blip2_image_text_matching', 'pretrain', device=device, is_eval=True)\n\n# Preprocess the raw image\nraw_image = Image.open('./data/image.jpg').convert('RGB')\nimg = vis_processors['eval'](raw_image).unsqueeze(0).to(torch.device('cuda:1' if torch.cuda.is_available() else 'cpu'))\n\n# Set the caption\ncaption = 'a bird on a tree'\n\n# Preprocess the caption\ntxt = txt_processors['eval'](caption)\n\n# Calculate the itm score\nitm_output = model({'image': img, 'text_input': txt}, match_head='itm')\nitm_scores = torch.nn.functional.softmax(itm_output, dim=1)\nprint(f'The image and text are matched with a probability of {itm_scores[:, 1].item():.3%}')", "instruction": "I require assistance in extracting information from an image. The image file './data/image.jpg' contains a dog and I need to determine if there's also a cat situated behind the dog. Could you please provide assistance with deciphering the relevant information from this image?", "oracle_segmet": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future."}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 5, "id": 34, "domain": "Multimodal", "task": "Instructed Generation", "readme": "https://github.com/salesforce/LAVIS/blob/main/README.md", "path": "./", "arguments": {"model": "blip2_t5", "type": "caption_coco_flant5xl", "img_path": "test.jpg"}, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\n# Set the device\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Load the model and preprocess the data\nmodel, vis_processors, _ = load_model_and_preprocess(model='blip2_t5', model_type='caption_coco_flant5xl')\n\n# Read and preprocess the image\nimage_path = 'test.jpg'\nimage = Image.open(image_path)\nraw_image = vis_processors['eval'](image).unsqueeze(0).to(device)\n\n# Generate the caption\ncaption = model.generate({'image': raw_image})\n\n# Print the generated caption\nprint('Generated caption:', caption)", "instruction": "I have an image titled 'test.jpg' and I'm interested in utilizing the blip2_t5 model along with its type caption_coco_flant5xl for image recognition. Could you assist me in generating a code to identify what is in the image?", "oracle_segmet": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future."}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 6, "id": 35, "domain": "Multimodal", "task": "Unified Feature Extraction", "readme": "https://github.com/salesforce/LAVIS/blob/main/README.md", "path": "./", "arguments": {"model": "albef_classification", "img_path": "picture.jpg", "argument": "mansion"}, "prefix_code": "", "output": "import torch\nfrom PIL import Image\nfrom lavis.models import load_model_and_preprocess\n\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Preprocessing raw_image\nraw_image = Image.open('picture.jpg')\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='albef_classification', model_type='ve')\n\nprocessed_image = vis_processors['eval'](raw_image).unsqueeze(0).to(device)\n\n# Set the caption of the picture\ncaption = 'a mansion'\n\n# Preprocess caption using txt_processors\nprocessed_caption = txt_processors['eval'](caption)\n\n# Extract features\nfeatures_image = model.extract_features({'image': processed_image})\nfeatures_text = model.extract_features({'text_input': [processed_caption]})\n\nfeatures_multimodal = model.extract_features({'image': processed_image, 'text_input': [processed_caption]})", "instruction": "I'd like help writing a code snippet. I would like to use the model 'albef_classification' to accomplish the feature extraction from images named 'picture.jpg' and 'a mansion'. Can you kindly assist me with this task?", "oracle_segmet": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future."}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 7, "id": 36, "domain": "Multimodal", "task": "Unified Feature Extraction", "readme": "https://github.com/salesforce/LAVIS/blob/main/README.md", "path": "./", "arguments": {"model": "blip_caption", "img_path": "./image/example.jpg"}, "prefix_code": "", "output": "from PIL import Image\nfrom lavis.models import load_model_and_preprocess\nimport torch\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\n\n# Preprocess raw_image\nraw_image = './image/example.jpg'\nimage = Image.open(raw_image)\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name='blip_caption', model_type='base_coco')\n\n# Set the caption\ncaption = 'a house'\n\n# Preprocess the caption for txt_processors\nprocessed_caption = txt_processors(['eval'])([caption])[0]\n\n# Extract features using model\ndevice = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu')\ninput_data = {'image': image, 'text_input': [processed_caption]}\nfeatures = model.extract_features(input_data)\n\n# Extract multimodal features\nfeatures_multimodal = features({'image': image, 'text_input': [processed_caption]})\n\n# Extract image features\nfeatures_image = features({'image': image}, mode='image')\n\n# Extract text features\nfeatures_text = features({'text_input': [processed_caption]}, mode='text')\n\n", "instruction": "I have a task to extract features from certain images and I want to utilize the 'blip_caption' module for this objective. Specifically, I am dealing with an image located at './image/example.jpg'. Could you guide me in the process of writing the code implementation required for this task?", "oracle_segmet": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future."}
{"github_id": 3, "github": "https://github.com/salesforce/lavis", "repo_id": 8, "id": 37, "domain": "Multimodal", "task": "Model Training", "readme": "https://github.com/salesforce/LAVIS/blob/main/README.md", "path": "./", "arguments": {"model": "blip2", "argument": "flant5xl", "dataset": "caption_coco"}, "prefix_code": "", "output": "python -m torch.distributed.run --nproc_per_node=8 evaluate.py --cfg-path lavis/projects/blip2/eval/caption_coco_flant5xl_eval.yaml", "instruction": "I have a task that involves performing an evaluation on a dataset named 'cap coco'. For this, I intend to use the 'blip2 flant5xl' model. Can you furnish me with a bit of guidance, so I can get the job done in the correct and efficient manner?", "oracle_segmet": "see how to use models in LAVIS to perform inference on example data. We first load a sample image from local.\\nimport torch\\nfrom PIL import Image\\n# setup device to use\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# load sample image\\nraw_image = Image.open(\\\"docs/_static/merlion.png\\\").convert(\\\"RGB\\\")\\nThis example image shows Merlion park (source), a landmark in Singapore.\\nImage Captioning\\nIn this example, we use the BLIP model to generate a caption for the image. To make inference even easier, we also associate each\\npre-trained model with its preprocessors (transforms), accessed via load_model_and_preprocess().\\nimport torch\\nfrom lavis.models import load_model_and_preprocess\\ndevice = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\")\\n# loads BLIP caption base model, with finetuned checkpoints on MSCOCO captioning dataset.\\n# this also loads the associated image processors\\nmodel, vis_processors, _ = load_model_and_preprocess(name=\\\"blip_caption\\\", model_type=\\\"base_coco\\\", is_eval=True, device=device)\\n# preprocess the image\\n# vis_processors stores image transforms for \\\"train\\\" and \\\"eval\\\" (validation / testing / inference)\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\n# generate caption\\nmodel.generate({\\\"image\\\": image})\\n# ['a large fountain spewing water into the air']\\nVisual question answering (VQA)\\nBLIP model is able to answer free-form questions about images in natural language.\\nTo access the VQA model, simply replace the name and model_type arguments\\npassed to load_model_and_preprocess().\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_vqa\\\", model_type=\\\"vqav2\\\", is_eval=True, device=device)\\n# ask a random question.\\nquestion = \\\"Which city is this photo taken?\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\nquestion = txt_processors[\\\"eval\\\"](question)\\nmodel.predict_answers(samples={\\\"image\\\": image, \\\"text_input\\\": question}, inference_method=\\\"generate\\\")\\n# ['singapore']\\nUnified Feature Extraction Interface\\nLAVIS provides a unified interface to extract features from each architecture.\\nTo extract features, we load the feature extractor variants of each model.\\nThe multimodal feature can be used for multimodal classification.\\nThe low-dimensional unimodal features can be used to compute cross-modal similarity.\\nfrom lavis.models import load_model_and_preprocess\\nmodel, vis_processors, txt_processors = load_model_and_preprocess(name=\\\"blip_feature_extractor\\\", model_type=\\\"base\\\", is_eval=True, device=device)\\ncaption = \\\"a large fountain spewing water into the air\\\"\\nimage = vis_processors[\\\"eval\\\"](raw_image).unsqueeze(0).to(device)\\ntext_input = txt_processors[\\\"eval\\\"](caption)\\nsample = {\\\"image\\\": image, \\\"text_input\\\": [text_input]}\\n\\nfeatures_multimodal = model.extract_features(sample)\\nprint(features_multimodal.multimodal_embeds.shape)\\n# torch.Size([1, 12, 768]), use features_multimodal[:,0,:] for multimodal classification tasks\\n\\nfeatures_image = model.extract_features(sample, mode=\\\"image\\\")\\nfeatures_text = model.extract_features(sample, mode=\\\"text\\\")\\nprint(features_image.image_embeds.shape)\\n# torch.Size([1, 197, 768])\\nprint(features_text.text_embeds.shape)\\n# torch.Size([1, 12, 768])\\n\\n# low-dimensional projected features\\nprint(features_image.image_embeds_proj.shape)\\n# torch.Size([1, 197, 256])\\nprint(features_text.text_embeds_proj.shape)\\n# torch.Size([1, 12, 256])\\nsimilarity = features_image.image_embeds_proj[:,0,:] @ features_text.text_embeds_proj[:,0,:].t()\\nprint(similarity)\\n# tensor([[0.2622]])\\nLoad Datasets\\nLAVIS inherently supports a wide variety of common language-vision datasets by providing automatic download tools to help download and organize these datasets. After downloading, to load the datasets, use the following code:\\nfrom lavis.datasets.builders import dataset_zoo\\ndataset_names = dataset_zoo.get_names()\\nprint(dataset_names)\\n# ['aok_vqa', 'coco_caption', 'coco_retrieval', 'coco_vqa', 'conceptual_caption_12m',\\n#  'conceptual_caption_3m', 'didemo_retrieval', 'flickr30k', 'imagenet', 'laion2B_multi',\\n#  'msrvtt_caption', 'msrvtt_qa', 'msrvtt_retrieval', 'msvd_caption', 'msvd_qa', 'nlvr',\\n#  'nocaps', 'ok_vqa', 'sbu_caption', 'snli_ve', 'vatex_caption', 'vg_caption', 'vg_vqa']\\nAfter downloading the images, we can use load_dataset() to obtain the dataset.\\nfrom lavis.datasets.builders import load_dataset\\ncoco_dataset = load_dataset(\\\"coco_caption\\\")\\nprint(coco_dataset.keys())\\n# dict_keys(['train', 'val', 'test'])\\nprint(len(coco_dataset[\\\"train\\\"]))\\n# 566747\\nprint(coco_dataset[\\\"train\\\"][0])\\n# {'image': <PIL.Image.Image image mode=RGB size=640x480>,\\n#  'text_input': 'A woman wearing a net on her head cutting a cake. ',\\n#  'image_id': 0}\\nIf you already host a local copy of the dataset, you can pass in the vis_path argument to change the default location to load images.\\ncoco_dataset = load_dataset(\\\"coco_caption\\\", vis_path=YOUR_LOCAL_PATH)\\nJupyter Notebook Examples\\nSee examples for more inference examples, e.g. captioning, feature extraction, VQA, GradCam, zeros-shot classification.\\nResources and Tools\\n\\nBenchmarks: see Benchmark for instructions to evaluate and train supported models.\\nDataset Download and Browsing: see Dataset Download for instructions and automatic tools on download common language-vision datasets.\\nGUI Demo: to run the demo locally, run bash run_scripts/run_demo.sh and then follow the instruction on the prompts to view in browser. A web demo is coming soon.\\n\\nDocumentations\\nFor more details and advanced usages, please refer to\\ndocumentation.\\nEthical and Responsible Use\\nWe note that models in LAVIS provide no guarantees on their multimodal abilities; incorrect or biased predictions may be observed. In particular, the datasets and pretrained models utilized in LAVIS may contain socioeconomic biases which could result in misclassification and other unwanted behaviors such as offensive or inappropriate speech. We strongly recommend that users review the pre-trained models and overall system in LAVIS before practical adoption. We plan to improve the library by investigating and mitigating these potential biases and\\ninappropriate behaviors in the future."}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 1, "id": 38, "domain": "Multimodal", "task": "Text to Image (Dream)", "readme": "https://github.com/deep-floyd/IF/blob/develop/README.md", "path": "./", "arguments": {"model": "IF-II-L-v1.0", "argument1": "5.0"}, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageII\nimport torch\n\ndevice = 'cuda:1'\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_II_kwargs = {'guidance_scale': 5.0, 'sample_timestep_respacing': 'smart50'}\n\nprompt = [\"Draw a picture of a dog.\"] * 4\n\nresult = if_II.dream(t5=None, if_I=None, if_II=if_II, if_III=None, prompt=prompt, seed=0, if_I_kwargs=None, if_II_kwargs=if_II_kwargs, if_III_kwargs=None)\n\nfor i, image_tensor in enumerate(result['II']):\n    image_tensor = image_tensor.to(device)\n    if_II.show({'II': image_tensor}, size=100)", "instruction": "Could you assist me in generating four visuals of dogs utilizing the IF-II-L-v1.0 model? I'd like the 'guidance_scale' parameter to be adjusted to 5.0. Provide me with the necessary code, if possible.", "oracle_segmet": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 2, "id": 39, "domain": "Multimodal", "task": "Text to Image (Dream)", "readme": "https://github.com/deep-floyd/IF/blob/develop/README.md", "path": "./", "arguments": {"model": "IF-II-L-v1.0", "argument1": "sample_timestep_respacing", "argument2": "smart100"}, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\nfrom deepfloyd_if.pipelines import dream\n\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\nprompt = [\"dog\"] * 4\nseed = 123\nif_I_kwargs = {'guidance_scale': 7.0, 'sample_timestep_respacing': 'smart100'}\nif_II_kwargs = {'guidance_scale': 4.0, 'sample_timestep_respacing': 'smart100'}\nif_III_kwargs = {'guidance_scale': 9.0, 'noise_level': 20, 'sample_timestep_respacing': '75'}\n\nresult = dream(\n    t5=t5,\n    if_I=if_I,\n    if_II=if_II,\n    if_III=if_III,\n    prompt=prompt,\n    seed=seed,\n    if_I_kwargs=if_I_kwargs,\n    if_II_kwargs=if_II_kwargs,\n    if_III_kwargs=if_III_kwargs\n)\n\nfor i in range(len(result['III'])):\n    if_III.show(result['III'][i], size=100)", "instruction": "Could you kindly assist me with drawing up some code? I aim to generate four dog images with the aid of the IF-II-L-v1.0 model. It's important that the parameter 'sample_timestep_respacing' is set to 'smart100'.", "oracle_segmet": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 3, "id": 40, "domain": "Multimodal", "task": "Zero-shot Image-to-Image Translation", "readme": "https://github.com/deep-floyd/IF/blob/develop/README.md", "path": "./", "arguments": {"model": "IF-I-M-v1.0", "argument1": "image.jpg", "argument2": "cartoon"}, "prefix_code": "", "output": "from deepfloyd_if.pipelines import style_transfer\n\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-M-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\ndevice='cuda:1'\n\nimage_path = 'image.jpg'\nstyle_prompt = \"a lively cartoon style\"\nseed = 123\n\nresult = style_transfer(t5=t5, if_I=IFStageI('IF-I-M-v1.0', device=device),                if_II=if_II, support_pil_img=None, original_style_img=image_path,               style_prompt=style_prompt, seed=seed,                if_I_kwargs={'guidance_scale': 10.0, 'sample_timestep_respacing': '10,10,10,10,10,10,10,10,0,0',                              'support_noise_less_qsample_steps': 5},               if_II_kwargs={'guidance_scale': 10.0, 'sample_timestep_respacing': 'smart50',                              'support_noise_less_qsample_steps': 5})\n\nif_I.show(result['II'], 1, 20)", "instruction": "There's an image named 'image'.jpg that I'd like to enhance. Could you guide me through the process of rendering it in an animated cartoon style using the IF-I-M-v1.0 model? I anticipate this will infuse it with an energetic and lively look.", "oracle_segmet": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 4, "id": 41, "domain": "Multimodal", "task": "Zero-shot Image-to-Image Translation", "readme": "https://github.com/deep-floyd/IF/blob/develop/README.md", "path": "./", "arguments": {"model": "IF-I-XL-v1.0", "argument1": "image.jpg", "argument2": "wash"}, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\n\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\nstyle_prompt = \"a captivating ink wash style\"\nimage_path = \"image.jpg\"\n\nresult = if_I.style_transfer(t5, if_I, if_II, image_path, style_prompt, seed=0, if_I_kwargs={'guidance_scale': 10.0, 'sample_timestep_respacing': '10,10,10,10,10,10,10,10,0,0', 'support_noise_less_qsample_steps': 5}, if_II_kwargs={'guidance_scale': 10.0, 'sample_timestep_respacing': 'smart50', 'support_noise_less_qsample_steps': 5})\n\nif_I.show(result['II'], 1, 20)", "instruction": "Time to create a visual masterpiece! I am excited to recreate 'image'.jpg into a fascinating rendition of the ink wash style. I am planning to utilize the capabilities of the IF-I-XL-v1.0 model for this endeavor. Can you assist me in crafting the necessary code?", "oracle_segmet": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 5, "id": 42, "domain": "Multimodal", "task": "Zero-shot Image-to-Image Translation", "readme": "https://github.com/deep-floyd/IF/blob/develop/README.md", "path": "./", "arguments": {"model": "IF-I-M-v1.0", "img_path": "example.jpg", "argument1": "example.jpg", "argument2": "ink"}, "prefix_code": "", "output": "code:\n```\n# Set the model\nif_I = IFStageI('IF-I-M-v1.0', device=device)\nif_II = IFStageII('IF-II-L-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\n\n# Load and preprocess the image\noriginal_style_img = Image.open('example.jpg')\nsupport_pil_img = original_style_img.resize((512, 512))\n\n# Define the style to transfer\nstyle_prompt = 'a stunning ink wash style'\n\n# Set the parameters for if_I and if_II\nif_I_kwargs = {'guidance_scale': 10.0, 'sample_timestep_respacing': '10,10,10,10,10,10,10,10,0,0', 'support_noise_less_qsample_steps': 5}\nif_II_kwargs = {'guidance_scale': 10.0, 'sample_timestep_respacing': 'smart50', 'support_noise_less_qsample_steps': 5}\n\n# Perform style transfer\nresult = style_transfer(t5, t5, if_I, if_II, support_pil_img, original_style_img, style_prompt, seed=None, if_I_kwargs=if_I_kwargs, if_II_kwargs=if_II_kwargs)\n\n# Show the result\nif_I.show(result['II'], 1, 20)\n```\n\nNote: Make sure to replace 'example.jpg' with the path to your actual image file.", "instruction": "I have a digital image titled 'example.jpg' that I hope to transform into an ink wash styled masterpiece with the IF-I-M-v1.0 model. Can you guide me to write the code to transform the image accordingly?", "oracle_segmet": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 6, "id": 43, "domain": "Multimodal", "task": "Super Resolution", "readme": "https://github.com/deep-floyd/IF/blob/develop/README.md", "path": "./", "arguments": {"model": "IF-I-L-v1.0", "img_path": "example.jpg", "argument1": "dog", "argument2": "7.0", "argument3": "30"}, "prefix_code": "", "output": "from deepfloyd_if.pipelines import super_resolution\n\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\ndevice = 'cuda:1'\nif_I = IFStageI('IF-I-L-v1.0', device=device)\nif_II = IFStageII('IF-II-M-v1.0', device=device)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\n# Step 1\ndevice='cuda:1'\n\nmid_result = super_resolution(\n    t5=t5,\n    if_II=IFStageII('IF-I-L-v1.0', device=device),\n    prompt=[\"I'm seeking your assistance for a Super Resolution Task on 'example.jpg', featuring a dog on a desk.\"],\n    support_pil_img='example.jpg',\n    image_scale=4,\n    image_size=64,\n    sample_timestep_respacing='smart100',\n    aug_level=0.5\n)\n\n# Step 2\nresult = super_resolution(\n    if_III=StableStageIII('stable-diffusion-x4-upscaler', device=device, guidance_scale=7.0),\n    prompt=[''],\n    support_pil_img=mid_result,\n    image_scale=4,\n    image_size=64,\n    sample_timestep_respacing='75',\n    noise_level=30\n)", "instruction": "I have an image named 'example.jpg' that shows a dog on a desk and I would like to implement a Super Resolution Task on it. My plan is to utilize the IF-I-L-v1.0 model from IF_II_kwags, set the parameter guidance_scale present in if_III_kwargs to 7.0, and adjust the noise_level to 30 during the second step. Can you guide me through this process and help me write the necessary code?", "oracle_segmet": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n"}
{"github_id": 4, "github": "https://github.com/deep-floyd/if", "repo_id": 7, "id": 44, "domain": "Multimodal", "task": "Super Resolution", "readme": "https://github.com/deep-floyd/IF/blob/develop/README.md", "path": "./", "arguments": {"model": "IF-II-M-v1.0", "img_path": "example.jpg", "arg": "resolution", "arg2": "7.0"}, "prefix_code": "", "output": "from deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\nfrom deepfloyd_if.modules.t5 import T5Embedder\n\ndevice = 'cuda:1'\nif_II = IFStageII('IF-II-M-v1.0', device=device, guidance_scale=7.0)\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\nt5 = T5Embedder(device='cpu')\n\noriginal_image_path = 'example.jpg'\nmid_result = pipelines.super_resolution(t5=t5, if_II=if_II, prompt=[\"I'd like to enhance the resolution of 'example.jpg,' which features a woman in a blue headscarf and sweater.\"], support_pil_img=original_image_path, image_scale=4, image_size=64, sample_timestep_respacing='smart100', aug_level=0.5)\nresult = pipelines.super_resolution(t5=t5, if_III=if_III, prompt=[''], support_pil_img=mid_result['III'][0], image_scale=4, image_size=64, sample_timestep_respacing='75', noise_level=20)\n\nshow_superres(original_image_path, result['III'][0])", "instruction": "I have an image named 'example.jpg' that showcases a woman wearing a blue headscarf and sweater, for which I wish to improve the resolution. To accomplish this, I'd like to employ the IF-II-M-v1.0 model and adjust the guidance_scale to 7.0. Could you help me write the necessary code?", "oracle_segmet": "Example\\nBefore you can use IF, you need to accept its usage conditions. To do so:\\n\\nMake sure to have a Hugging Face account and be loggin in\\nAccept the license on the model card of DeepFloyd/IF-I-XL-v1.0\\nMake sure to login locally. Install huggingface_hub\\n\\npip install huggingface_hub --upgrade\\nrun the login function in a Python shell\\nfrom huggingface_hub import login\\n\\nlogin()\\nand enter your Hugging Face Hub access token.\\nNext we install diffusers and dependencies:\\npip install diffusers accelerate transformers safetensors\\nAnd we can now run the model locally.\\nBy default diffusers makes use of model cpu offloading to run the whole IF pipeline with as little as 14 GB of VRAM.\\nIf you are using torch>=2.0.0, make sure to delete all enable_xformers_memory_efficient_attention()\\nfunctions.\\nfrom diffusers import DiffusionPipeline\\nfrom diffusers.utils import pt_to_pil\\nimport torch\\n\\n# stage 1\\nstage_1 = DiffusionPipeline.from_pretrained(\\\"DeepFloyd/IF-I-XL-v1.0\\\", variant=\\\"fp16\\\", torch_dtype=torch.float16)\\nstage_1.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_1.enable_model_cpu_offload()\\n\\n# stage 2\\nstage_2 = DiffusionPipeline.from_pretrained(\\n    \\\"DeepFloyd/IF-II-L-v1.0\\\", text_encoder=None, variant=\\\"fp16\\\", torch_dtype=torch.float16\\n)\\nstage_2.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_2.enable_model_cpu_offload()\\n\\n# stage 3\\nsafety_modules = {\\\"feature_extractor\\\": stage_1.feature_extractor, \\\"safety_checker\\\": stage_1.safety_checker, \\\"watermarker\\\": stage_1.watermarker}\\nstage_3 = DiffusionPipeline.from_pretrained(\\\"stabilityai/stable-diffusion-x4-upscaler\\\", **safety_modules, torch_dtype=torch.float16)\\nstage_3.enable_xformers_memory_efficient_attention()  # remove line if torch.__version__ >= 2.0.0\\nstage_3.enable_model_cpu_offload()\\n\\nprompt = 'a photo of a kangaroo wearing an orange hoodie and blue sunglasses standing in front of the eiffel tower holding a sign that says \\\"very deep learning\\\"'\\n\\n# text embeds\\nprompt_embeds, negative_embeds = stage_1.encode_prompt(prompt)\\n\\ngenerator = torch.manual_seed(0)\\n\\n# stage 1\\nimage = stage_1(prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\").images\\npt_to_pil(image)[0].save(\\\"./if_stage_I.png\\\")\\n\\n# stage 2\\nimage = stage_2(\\n    image=image, prompt_embeds=prompt_embeds, negative_prompt_embeds=negative_embeds, generator=generator, output_type=\\\"pt\\\"\\n).images\\npt_to_pil(image)[0].save(\\\"./if_stage_II.png\\\")\\n\\n# stage 3\\nimage = stage_3(prompt=prompt, image=image, generator=generator, noise_level=100).images\\nimage[0].save(\\\"./if_stage_III.png\\\")\\nThere are multiple ways to speed up the inference time and lower the memory consumption even more with diffusers. To do so, please have a look at the Diffusers docs:\\n\\n\ud83d\ude80 Optimizing for inference time\\n\u2699\ufe0f Optimizing for low memory during inference\\n\\nFor more in-detail information about how to use IF, please have a look at the IF blog post and the documentation \ud83d\udcd6.\\nDiffusers dreambooth scripts also supports fine-tuning \ud83c\udfa8 IF.\\nWith parameter efficient finetuning, you can add new concepts to IF with a single GPU and ~28 GB VRAM.\\nRun the code locally\\nLoading the models into VRAM\\nfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\\nfrom deepfloyd_if.modules.t5 import T5Embedder\\n\\ndevice = 'cuda:0'\\nif_I = IFStageI('IF-I-XL-v1.0', device=device)\\nif_II = IFStageII('IF-II-L-v1.0', device=device)\\nif_III = StableStageIII('stable-diffusion-x4-upscaler', device=device)\\nt5 = T5Embedder(device=\\\"cpu\\\")\\nI. Dream\\nDream is the text-to-image mode of the IF model\\nfrom deepfloyd_if.pipelines import dream\\n\\nprompt = 'ultra close-up color photo portrait of rainbow owl with deer horns in the woods'\\ncount = 4\\n\\nresult = dream(\\n    t5=t5, if_I=if_I, if_II=if_II, if_III=if_III,\\n    prompt=[prompt]*count,\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart100\\\",\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": \\\"smart50\\\",\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\n\\nif_III.show(result['III'], size=14)\\n\\nII. Zero-shot Image-to-Image Translation\\n\\nIn Style Transfer mode, the output of your prompt comes out at the style of the support_pil_img\\nfrom deepfloyd_if.pipelines import style_transfer\\n\\nresult = style_transfer(\\n    t5=t5, if_I=if_I, if_II=if_II,\\n    support_pil_img=raw_pil_image,\\n    style_prompt=[\\n        'in style of professional origami',\\n        'in style of oil art, Tate modern',\\n        'in style of plastic building bricks',\\n        'in style of classic anime from 1990',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 10.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,10,10,10,0,0\\\",\\n        'support_noise_less_qsample_steps': 5,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        \\\"sample_timestep_respacing\\\": 'smart50',\\n        \\\"support_noise_less_qsample_steps\\\": 5,\\n    },\\n)\\nif_I.show(result['II'], 1, 20)\\n\\nIII. Super Resolution\\nFor super-resolution, users can run IF-II and IF-III or 'Stable x4' on an image that was not necessarely generated by IF (two cascades):\\nfrom deepfloyd_if.pipelines import super_resolution\\n\\nmiddle_res = super_resolution(\\n    t5,\\n    if_III=if_II,\\n    prompt=['woman with a blue headscarf and a blue sweaterp, detailed picture, 4k dslr, best quality'],\\n    support_pil_img=raw_pil_image,\\n    img_scale=4.,\\n    img_size=64,\\n    if_III_kwargs={\\n        'sample_timestep_respacing': 'smart100',\\n        'aug_level': 0.5,\\n        'guidance_scale': 6.0,\\n    },\\n)\\nhigh_res = super_resolution(\\n    t5,\\n    if_III=if_III,\\n    prompt=[''],\\n    support_pil_img=middle_res['III'][0],\\n    img_scale=4.,\\n    img_size=256,\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nshow_superres(raw_pil_image, high_res['III'][0])\\n\\nIV. Zero-shot Inpainting\\nfrom deepfloyd_if.pipelines import inpainting\\n\\nresult = inpainting(\\n    t5=t5, if_I=if_I,\\n    if_II=if_II,\\n    if_III=if_III,\\n    support_pil_img=raw_pil_image,\\n    inpainting_mask=inpainting_mask,\\n    prompt=[\\n        'oil art, a man in a hat',\\n    ],\\n    seed=42,\\n    if_I_kwargs={\\n        \\\"guidance_scale\\\": 7.0,\\n        \\\"sample_timestep_respacing\\\": \\\"10,10,10,10,10,0,0,0,0,0\\\",\\n        'support_noise_less_qsample_steps': 0,\\n    },\\n    if_II_kwargs={\\n        \\\"guidance_scale\\\": 4.0,\\n        'aug_level': 0.0,\\n        \\\"sample_timestep_respacing\\\": '100',\\n    },\\n    if_III_kwargs={\\n        \\\"guidance_scale\\\": 9.0,\\n        \\\"noise_level\\\": 20,\\n        \\\"sample_timestep_respacing\\\": \\\"75\\\",\\n    },\\n)\\nif_I.show(result['I'], 2, 3)\\nif_I.show(result['II'], 2, 6)\\nif_I.show(result['III'], 2, 14)\\n\\n\ud83e\udd17 Model Zoo \ud83e\udd17\\nThe link to download the weights as well as the model cards will be available soon on each model of the model zoo\\nOriginal\\n\\n\\n\\nName\\nCascade\\nParams\\nFID\\nBatch size\\nSteps\\n\\n\\n\\n\\nIF-I-M\\nI\\n400M\\n8.86\\n3072\\n2.5M\\n\\n\\nIF-I-L\\nI\\n900M\\n8.06\\n3200\\n3.0M\\n\\n\\nIF-I-XL*\\nI\\n4.3B\\n6.66\\n3072\\n2.42M\\n\\n\\nIF-II-M\\nII\\n450M\\n-\\n1536\\n2.5M\\n\\n\\nIF-II-L*\\nII\\n1.2B\\n-\\n1536\\n2.5M\\n\\n\\nIF-III-L* (soon)\\nIII\\n700M\\n-\\n3072\\n1.25M\\n\\n\\n\\n*best modules\\nQuantitative Evaluation\\nFID = 6.66\\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 1, "id": 45, "domain": "Video", "task": "Edge to Face", "readme": "https://github.com/NVIDIA/vid2vid/blob/master/README.md", "path": "./", "arguments": {"model": "edge2face", "dataset": "face", "resolusion size": "512"}, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py\npython scripts/download_flownet2.py\npython scripts/face/download_models.py", "output": "python test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512", "instruction": "I'm planning to employ the model edge2face on a face dataset, realizing a resolution of 512. Can you assist in outlining the appropriate code structure?", "oracle_segmet": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 2, "id": 46, "domain": "Video", "task": "Pose to Body", "readme": "https://github.com/NVIDIA/vid2vid/blob/master/README.md", "path": "./", "arguments": {"model": "pose2body", "dataset": "pose", "resolusion size": "256", "argument": "g1"}, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py\npython scripts/download_flownet2.py", "output": "python test.py --name pose2body_256p_g1 --dataroot datasets/pose --dataset_mode pose --ngf 64 --input_nc 6 --resize_or_crop scaleHeight --loadSize 256 --no_first_img", "instruction": "I'm desiring to put the pose2body model to the test. More specifically, I want to implement this model on a pose dataset with a resolution size of 256 while utilizing a single GPU. Could you help me craft the necessary programming instructions for this endeavor?", "oracle_segmet": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 3, "id": 47, "domain": "Video", "task": "Edge to Face Training", "readme": "https://github.com/NVIDIA/vid2vid/blob/master/README.md", "path": "./", "arguments": {"model": "edge2face", "dataset": "face", "resolusion size": "256", "argument": "g1"}, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py", "output": "python train.py --name edge2face_256_g1 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 256 --ngf 64 --max_frames_per_gpu 6 --n_frames_total 12 --niter 20 --niter_decay 20", "instruction": "We have the task of training the edge2face model on a face dataset. Let's set the resolution size this time to 256. Can you provide assistance in drafting the applicable coding structure?", "oracle_segmet": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 4, "id": 48, "domain": "Video", "task": "Edge to Face Training", "readme": "https://github.com/NVIDIA/vid2vid/blob/master/README.md", "path": "./", "arguments": {"model": "edge2face", "dataset": "face", "resolusion size": "256", "max_frames_per_gpu": "4", "argument": "g1"}, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py", "output": "python train.py --name edge2face_256_g1 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 256 --ngf 64 --max_frames_per_gpu 4 --n_frames_total 12 --niter 20 --niter_decay 30", "instruction": "I need to train an edge2face model on a face dataset. Make sure the resolution size is set at 256 and don't forget to limit the maximum number of frames per GPU to 4. Can you assist me in drafting the right code to accomplish this?", "oracle_segmet": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 5, "id": 49, "domain": "Video", "task": "Pose to Body Training", "readme": "https://github.com/NVIDIA/vid2vid/blob/master/README.md", "path": "./", "arguments": {"model": "pose2body", "dataset": "pose", "resolusion size": "1024p", "argument": "g1"}, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py", "output": "python train.py --name pose2body_1024p_g1 --dataroot datasets/pose --dataset_mode pose --input_nc 6 --n_scales_spatial 3 --num_D 4 --ngf 64 --ndf 32 --resize_or_crop randomScaleHeight_and_scaledCrop --loadSize 1536 --fineSize 1024 --no_first_img --n_frames_total 12 --max_t_step 4 --add_face_disc --niter_fix_global 3 --niter 5 --niter_decay 5 --lr 0.00005 --load_pretrain checkpoints/pose2body_512p_g1", "instruction": "We wish to utilize the pose2body model for training purposes, operating on a standalone GPU. The training set in use is the 'pose' dataset. We're aiming to maximally leverage the computational resources at our disposal by choosing a high-resolution size of 1024p. Could you assist us in constructing the appropriate algorithm for this situation?", "oracle_segmet": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 6, "id": 50, "domain": "Video", "task": "Pose to Body Training", "readme": "https://github.com/NVIDIA/vid2vid/blob/master/README.md", "path": "./", "arguments": {"model": "pose2body", "dataset": "pose", "resolusion size": "256p", "argument": "g1"}, "prefix_code": "pip install dominate requests\npython scripts/download_datasets.py", "output": "python train.py --name pose2body_256p_g1 --dataroot datasets/pose --dataset_mode pose --input_nc 6 --ngf 64 --num_D 2 --resize_or_crop randomScaleHeight_and_scaledCrop --loadSize 384 --fineSize 256 --niter 5 --niter_decay 5 --no_first_img --n_frames_total 12 --max_frames_per_gpu 4 --max_t_step 4", "instruction": "I need assistance in training the pose2body model specifically on a single GPU. For optimization, I suggest we utilize a smaller size such as 256p for the pose dataset. This approach should enhance performance without overburdening the GPU. Could you guide me through the code necessary for this task?", "oracle_segmet": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 7, "id": 51, "domain": "Video", "task": "Label to City Training", "readme": "https://github.com/NVIDIA/vid2vid/blob/master/README.md", "path": "./", "arguments": {"model": "label2city", "dataset": "city", "resolusion size": "512"}, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_512_no_fg --label_nc 35 --loadSize 512 --use_instance --gpu_ids 0,1,2,3,4,5,6,7 --n_gpus_gen 6 --n_frames_total 6 --max_frames_per_gpu 2 ", "instruction": "In order to improve performance, I would suggest utilizing the label2city model to conduct training on the Cityscapes dataset, with an exceptional characteristic that none of the foreground objects are to be included. Additionally, the resolution of the images used in the training should be set to a size of 512 pixels. Could you provide some code samples that could accomplish this task?", "oracle_segmet": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n"}
{"github_id": 5, "github": "https://github.com/NVIDIA/vid2vid", "repo_id": 8, "id": 52, "domain": "Video", "task": "Label to City Training", "readme": "https://github.com/NVIDIA/vid2vid/blob/master/README.md", "path": "./", "arguments": {"model": "label2city", "dataset": "city", "resolusion size": "1024"}, "prefix_code": "pip install dominate requests\npython scripts/download_models_flownet2.py", "output": "python train.py --name label2city_1024 --label_nc 35 --loadSize 1024 --n_scales_spatial 2 --num_D 3 --use_instance --fg --gpu_ids 0,1,2,3,4,5,6,7 --n_gpus_gen 4 --n_frames_total 4 --niter_step 2 --niter_fix_global 10 --load_pretrain checkpoints/label2city_512 --lr 0.0001", "instruction": "We're embarking on a project to use the label2city model on the Cityscapes dataset for training purposes. Our target resolution size is 1024 pixels. Could you help in formulating the necessary guidelines to accomplishing this task?", "oracle_segmet": "Testing\\n\\n\\nPlease first download example dataset by running python scripts/download_datasets.py.\\n\\n\\nNext, compile a snapshot of FlowNet2 by running python scripts/download_flownet2.py.\\n\\n\\nCityscapes\\n\\n\\nPlease download the pre-trained Cityscapes model by:\\npython scripts/street/download_models.py\\n\\n\\nTo test the model (bash ./scripts/street/test_2048.sh):\\n#!./scripts/street/test_2048.sh\\npython test.py --name label2city_2048 --label_nc 35 --loadSize 2048 --n_scales_spatial 3 --use_instance --fg --use_single_G\\nThe test results will be saved in: ./results/label2city_2048/test_latest/.\\n\\n\\nWe also provide a smaller model trained with single GPU, which produces slightly worse performance at 1024 x 512 resolution.\\n\\nPlease download the model by\\n\\npython scripts/street/download_models_g1.py\\n\\nTo test the model (bash ./scripts/street/test_g1_1024.sh):\\n\\n#!./scripts/street/test_g1_1024.sh\\npython test.py --name label2city_1024_g1 --label_nc 35 --loadSize 1024 --n_scales_spatial 3 --use_instance --fg --n_downsample_G 2 --use_single_G\\n\\n\\nYou can find more example scripts in the scripts/street/ directory.\\n\\n\\n\\n\\nFaces\\n\\nPlease download the pre-trained model by:\\npython scripts/face/download_models.py\\n\\nTo test the model (bash ./scripts/face/test_512.sh):\\n#!./scripts/face/test_512.sh\\npython test.py --name edge2face_512 --dataroot datasets/face/ --dataset_mode face --input_nc 15 --loadSize 512 --use_single_G\\nThe test results will be saved in: ./results/edge2face_512/test_latest/.\\n"}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 1, "id": 53, "domain": "Multimodal", "task": "Image classification", "readme": "https://github.com/mlfoundations/open_clip/blob/main/README.md", "path": "./", "arguments": {"model": "ViT-B-32", "argument2": "ViT-B-32", "argument3": "laion400m_e31"}, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion400m_e31')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()", "instruction": "I need assistance in arranging some images. I would like to use the ViT-B-32 model and Pretraining model laion400m_e31. Would you be able to aid me in creating the necessary code?", "oracle_segmet": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory."}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 2, "id": 54, "domain": "Multimodal", "task": "Image classification", "readme": "https://github.com/mlfoundations/open_clip/blob/main/README.md", "path": "./", "arguments": {"model": "convnext_large_d", "argument2": "convnext_large_d", "argument3": "laion2b_s26b_b102k_augreg", "argument4": "./usr/image", "argument5": "plane': 'A plane is flying in the blue sky'", "cat": "A grey and white cat"}, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('convnext_large_d', pretrained='laion2b_s26b_b102k_augreg')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()", "instruction": "I need assistance in sorting some pictures, utilizing the model convnext_large_d and the Pretraining modellaion2b_s26b_b102k_augreg. The exact location of the images is ./usr/image. And a detailed description of each image is given as: For 'plane', it's 'A plane is flying in the blue sky' and for 'cat', it's 'A grey and white cat'. Can you walk me through the steps of coding this task?", "oracle_segmet": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory."}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 3, "id": 55, "domain": "Multimodal", "task": "Image classification", "readme": "https://github.com/mlfoundations/open_clip/blob/main/README.md", "path": "./", "arguments": {"model": "EVA02-E-14", "argument2": "EVA02-E-14", "argument3": "laion2b_s4b_b115k", "argument4": "./usr/image", "argument5": "A cat was driving on the road", "cat": "A brown dog was lying on the ground"}, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('EVA02-E-14', pretrained='laion2b_s4b_b115k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()", "instruction": "I'd like your assistance in sorting a set of images in the directory ./usr/image using the EVA02-E-14 model in conjunction with the Pretraining model laion2b_s4b_b115k. The images are labeled as 'plane' and 'cat' with descriptions 'A plane is flying in the blue sky' and 'A grey and white cat' respectively. Could you help me construct the necessary code?", "oracle_segmet": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory."}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 4, "id": 56, "domain": "Multimodal", "task": "Image classification", "readme": "https://github.com/mlfoundations/open_clip/blob/main/README.md", "path": "./", "arguments": {"model": "ViT-B-32", "argument2": "ViT-B-32", "argument3": "commonpool_s_laion_s13m_b4k", "argument4": "./image"}, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='commonpool_s_laion_s13m_b4k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'plane': 'A plane is flying in the blue sky',\n    'cat': 'A grey and white cat'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()", "instruction": "I'm hoping you could assist me with a task. I need to sort a collection of images located at the directory '. /image'. For this purpose, I'll be using the 'ViT-B-32' model along with the pretraining model 'commonpool_s_laion_s13m_b4k'. Would you be able to provide instructions or steps on how to accomplish this task?", "oracle_segmet": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory."}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 5, "id": 57, "domain": "Multimodal", "task": "Image classification", "readme": "https://github.com/mlfoundations/open_clip/blob/main/README.md", "path": "./", "arguments": {"model": "convnext_xxlarge", "argument2": "convnext_xxlarge", "argument3": "laion2b_s34b_b82k_augreg_rewind", "argument4": "./usr/image", "argument5": "A cat was driving on the road", "dog": "A brown dog was lying on the ground"}, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('convnext_xxlarge', pretrained='laion2b_s34b_b82k_augreg_rewind')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'cat': 'A cat was driving on the road',\n    'dog': 'A brown dog was lying on the ground'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()", "instruction": "My goal is to organize a set of images using the convnext_xxlargemodel and Pretraining laion2b_s34b_b82k_augreg_rewind module. The images can be found at this path: './usr/image'. Also, here is a brief description of the images I'm working with:", "oracle_segmet": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory."}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 6, "id": 58, "domain": "Multimodal", "task": "Image classification", "readme": "https://github.com/mlfoundations/open_clip/blob/main/README.md", "path": "./", "arguments": {"model": "ViT-B-16", "argument2": "ViT-B-16", "argument3": "commonpool_l_text_s1b_b8k", "argument4": "./usr/image", "argument5": "A cat was driving on the road", "dog": "A brown dog was lying on the ground"}, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-16', pretrained='commonpool_l_text_s1b_b8k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'cat': 'A cat was driving on the road',\n    'dog': 'A brown dog was lying on the ground'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()", "instruction": "Kindly sort these pictures by utilizing the ViT-B-16 model in conjunction with the pretraining model commonpool_l_text_s1b_b8k. The image source directory is ./usr/image. Further details for each image are as follows: 'cat': 'A cat was driving on the road', 'dog': 'A brown dog was lying on the ground. Refer to these to create meaningful code.", "oracle_segmet": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory."}
{"github_id": 7, "github": "https://github.com/mlfoundations/open_clip", "repo_id": 7, "id": 59, "domain": "Multimodal", "task": "Image classification", "readme": "https://github.com/mlfoundations/open_clip/blob/main/README.md", "path": "./", "arguments": {"model": "ViT-B-16", "argument2": "ViT-B-16", "argument3": "laion2b_s34b_b88k"}, "prefix_code": "", "output": "import os\nimport numpy as np\nimport torch\nimport open_clip\nopen_clip.list_pretrained()\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-16', pretrained='laion2b_s34b_b88k')\nmodel.eval()\ncontext_length = model.context_length\nvocab_size = model.vocab_size\nprint('Model parameters:', f'{np.sum([int(np.prod(p.shape)) for p in model.parameters()]):,}')\nprint('Context length:', context_length)\nprint('Vocab size:', vocab_size)\nfrom open_clip import tokenizer\ntokenizer.tokenize('Hello World!')\nimport os\nimport skimage\n\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport numpy as np\nfrom collections import OrderedDict\nimport torch\n# %matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\ndescriptions = {\n    'cat': 'There is a cat moving on the road', 'dog': 'A brown dog is resting on the ground'\n}\noriginal_images = []\nimages = []\ntexts = []\nplt.figure(figsize=(16, 5))\npath = './usr/image'\nfor filename in [filename for filename in os.listdir(path) if filename.endswith('.png') or filename.endswith('.jpg')]:\n    name = os.path.splitext(filename)[0]\n    if name not in descriptions:\n        continue\n    image = Image.open(os.path.join(path, filename)).convert('RGB')\n    plt.subplot(2, 4, len(images) + 1)\n    plt.imshow(image)\n    plt.title(f'{filename}{descriptions[name]}')\n    plt.xticks([])\n    plt.yticks([])\n    original_images.append(image)\n    images.append(preprocess(image))\n    texts.append(descriptions[name])\nplt.tight_layout()\nimage_input = torch.tensor(np.stack(images))\ntext_tokens = tokenizer.tokenize(['This is ' + desc for desc in texts])\nwith torch.no_grad():\n    image_features = model.encode_image(image_input).float()\n    text_features = model.encode_text(text_tokens).float()\nimage_features /= image_features.norm(dim=-1, keepdim=True)\ntext_features /= text_features.norm(dim=-1, keepdim=True)\nsimilarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\ncount = len(descriptions)\nplt.figure(figsize=(20, 14))\nplt.imshow(similarity, vmin=0.1, vmax=0.3)\n# plt.colorbar()\n\nfor i, image in enumerate(original_images):\n    plt.imshow(image, extent=(i - 0.5, i + 0.5, -1.6, -0.6), origin='lower')\nfor x in range(similarity.shape[1]):\n    for y in range(similarity.shape[0]):\n        plt.text(x, y, f'{similarity[y, x]:.2f}', ha='center', va='center', size=12)\nfor side in ['left', 'top', 'right', 'bottom']:\n  plt.gca().spines[side].set_visible(False)\nplt.xlim([-0.5, count - 0.5])\nplt.ylim([count + 0.5, -2])\nplt.title('Cosine similarity between text and image features', size=20)\nfrom torchvision.datasets import CIFAR100\ncifar100 = CIFAR100(os.path.expanduser('~/.cache'), transform=preprocess, download=True)\ntext_descriptions =[f'A photo of a {label}' for label in cifar100.classes]\ntext_tokens = tokenizer.tokenize(text_descriptions)\nwith torch.no_grad():\n    text_features = model.encode_text(text_tokens).float()\n    text_features /= text_features.norm(dim=-1, keepdim=True)\ntext_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1)\ntop_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\nplt.figure(figsize=(16, 16))\nfor i, image in enumerate(original_images):\n    plt.subplot(4, 4, 2 * i + 1)\n    plt.imshow(image)\n    plt.axis('off')\n    plt.subplot(4, 4, 2 * i + 2)\n    y = np.arange(top_probs.shape[-1])\n    plt.grid()\n    plt.barh(y, top_probs[i])\n    plt.gca().invert_yaxis()\n    plt.gca().set_axisbelow(True)\n\n    plt.xlabel('probability')\nplt.subplots_adjust(wspace=0.5)\nplt.show()", "instruction": "I need your help in organizing some images I have. The model I wish to utilize for this task is ViT-B-16, and I also want to implement the Pretraining model laion2b_s34b_b88k. Can you guide me through writing the required code for this endeavor?", "oracle_segmet": "To see which pretrained models are available, use the following code snippet.\\nMore details about our pretrained models are available here.\\n>>> import open_clip\\n>>> open_clip.list_pretrained()\\nYou can find more about the models we support (e.g. number of parameters, FLOPs) in this table.\\nNOTE: Many existing checkpoints use the QuickGELU activation from the original OpenAI models. This activation is actually less efficient than native torch.nn.GELU in recent versions of PyTorch. The model defaults are now nn.GELU, so one should use model definitions with -quickgelu postfix for the OpenCLIP pretrained weights. All OpenAI pretrained weights will always default to QuickGELU. One can also use the non -quickgelu model definitions with pretrained weights using QuickGELU but there will be an accuracy drop, for fine-tune that will likely vanish for longer runs.\\nFuture trained models will use nn.GELU.\\nLoading models\\nModels can be loaded with open_clip.create_model_and_transforms, as shown in the example below. The model name and corresponding pretrained keys are compatible with the outputs of open_clip.list_pretrained().\\nThe pretrained argument also accepts local paths, for example /path/to/my/b32.pt.\\nYou can also load checkpoints from huggingface this way. To do so, download the open_clip_pytorch_model.bin file (for example, https://huggingface.co/laion/CLIP-ViT-L-14-DataComp.XL-s13B-b90K/tree/main), and use pretrained=/path/to/open_clip_pytorch_model.bin.\\n# pretrained also accepts local paths\\nmodel, _, preprocess = open_clip.create_model_and_transforms('ViT-B-32', pretrained='laion2b_s34b_b79k') \\nFine-tuning on classification tasks\\nThis repository is focused on training CLIP models. To fine-tune a trained zero-shot model on a downstream classification task such as ImageNet, please see our other repository: WiSE-FT. The WiSE-FT repository contains code for our paper on Robust Fine-tuning of Zero-shot Models, in which we introduce a technique for fine-tuning zero-shot models while preserving robustness under distribution shift.\\nData\\nTo download datasets as webdataset, we recommend img2dataset.\\nConceptual Captions\\nSee cc3m img2dataset example.\\nYFCC and other datasets\\nIn addition to specifying the training data via CSV files as mentioned above, our codebase also supports webdataset, which is recommended for larger scale datasets. The expected format is a series of .tar files. Each of these .tar files should contain two files for each training example, one for the image and one for the corresponding text. Both files should have the same name but different extensions. For instance, shard_001.tar could contain files such as abc.jpg and abc.txt. You can learn more about webdataset at https://github.com/webdataset/webdataset. We use .tar files with 1,000 data points each, which we create using tarp.\\nYou can download the YFCC dataset from Multimedia Commons.\\nSimilar to OpenAI, we used a subset of YFCC to reach the aforementioned accuracy numbers.\\nThe indices of images in this subset are in OpenAI's CLIP repository.\\nTraining CLIP\\nInstall\\nWe advise you first create a virtual environment with:\\npython3 -m venv .env\\nsource .env/bin/activate\\npip install -U pip\\n\\nYou can then install openclip for training with pip install 'open_clip_torch[training]'.\\nDevelopment\\nIf you want to make changes to contribute code, you can clone openclip then run make install in openclip folder (after creating a virtualenv)\\nInstall pip PyTorch as per https://pytorch.org/get-started/locally/\\nYou may run make install-training to install training deps\\nTesting\\nTest can be run with make install-test then make test\\npython -m pytest -x -s -v tests -k \\\"training\\\" to run a specific test\\nRunning regression tests against a specific git revision or tag:\\n\\n\\nGenerate testing data\\npython tests/util_test.py --model RN50 RN101 --save_model_list models.txt --git_revision 9d31b2ec4df6d8228f370ff20c8267ec6ba39383\\nWARNING: This will invoke git and modify your working tree, but will reset it to the current state after data has been generated! \\nDon't modify your working tree while test data is being generated this way.\\n\\n\\nRun regression tests\\nOPEN_CLIP_TEST_REG_MODELS=models.txt python -m pytest -x -s -v -m regression_test\\n\\n\\nSample single-process running code:\\npython -m training.main \\\\\\n    --save-frequency 1 \\\\\\n    --zeroshot-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\"  \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --csv-img-key filepath \\\\\\n    --csv-caption-key title \\\\\\n    --imagenet-val=/path/to/imagenet/root/val/ \\\\\\n    --warmup 10000 \\\\\\n    --batch-size=128 \\\\\\n    --lr=1e-3 \\\\\\n    --wd=0.1 \\\\\\n    --epochs=30 \\\\\\n    --workers=8 \\\\\\n    --model RN50\\nNote: imagenet-val is the path to the validation set of ImageNet for zero-shot evaluation, not the training set!\\nYou can remove this argument if you do not want to perform zero-shot evaluation on ImageNet throughout training. Note that the val folder should contain subfolders. If it does not, please use this script.\\nMulti-GPU and Beyond\\nThis code has been battle tested up to 1024 A100s and offers a variety of solutions\\nfor distributed training. We include native support for SLURM clusters.\\nAs the number of devices used to train increases, so does the space complexity of\\nthe the logit matrix. Using a na\u00efve all-gather scheme, space complexity will be\\nO(n^2). Instead, complexity may become effectively linear if the flags\\n--gather-with-grad and --local-loss are used. This alteration results in one-to-one\\nnumerical results as the na\u00efve method.\\nEpochs\\nFor larger datasets (eg Laion2B), we recommend setting --train-num-samples to a lower value than the full epoch, for example --train-num-samples 135646078 to 1/16 of an epoch in conjunction with --dataset-resampled to do sampling with replacement. This allows having frequent checkpoints to evaluate more often.\\nPatch Dropout\\nRecent research has shown that one can dropout half to three-quarters of the visual tokens, leading to up to 2-3x training speeds without loss of accuracy.\\nYou can set this on your visual transformer config with the key patch_dropout.\\nIn the paper, they also finetuned without the patch dropout at the end. You can do this with the command-line argument --force-patch-dropout 0.\\nMultiple data sources\\nOpenCLIP supports using multiple data sources, by separating different data paths with ::.\\nFor instance, to train on CC12M and on LAION, one might use --train-data \\\"/data/cc12m/cc12m-train-{0000..2175}.tar::/data/LAION-400M/{00000..41455}.tar\\\".\\nUsing --dataset-resampled is recommended for these cases.\\nBy default, on expectation the amount of times the model will see a sample from each source is proportional to the size of the source.\\nFor instance, when training on one data source with size 400M and one with size 10M, samples from the first source are 40x more likely to be seen in expectation.\\nWe also support different weighting of the data sources, by using the --train-data-upsampling-factors flag.\\nFor instance, using --train-data-upsampling-factors=1::1 in the above scenario is equivalent to not using the flag, and --train-data-upsampling-factors=1::2 is equivalent to upsampling the second data source twice.\\nIf you want to sample from data sources with the same frequency, the upsampling factors should be inversely proportional to the sizes of the data sources.\\nFor instance, if dataset A has 1000 samples and dataset B has 100 samples, you can use --train-data-upsampling-factors=0.001::0.01 (or analogously, --train-data-upsampling-factors=1::10).\\nSingle-Node\\nWe make use of torchrun to launch distributed jobs. The following launches a\\na job on a node of 4 GPUs:\\ncd open_clip/src\\ntorchrun --nproc_per_node 4 -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nMulti-Node\\nThe same script above works, so long as users include information about the number\\nof nodes and host node.\\ncd open_clip/src\\ntorchrun --nproc_per_node=4 \\\\\\n    --rdzv_endpoint=$HOSTE_NODE_ADDR \\\\\\n    -m training.main \\\\\\n    --train-data '/data/cc12m/cc12m-train-{0000..2175}.tar' \\\\\\n    --train-num-samples 10968539 \\\\\\n    --dataset-type webdataset \\\\\\n    --batch-size 320 \\\\\\n    --precision amp \\\\\\n    --workers 4 \\\\\\n    --imagenet-val /data/imagenet/validation/\\nSLURM\\nThis is likely the easiest solution to utilize. The following script was used to\\ntrain our largest models:\\n#!/bin/bash -x\\n#SBATCH --nodes=32\\n#SBATCH --gres=gpu:4\\n#SBATCH --ntasks-per-node=4\\n#SBATCH --cpus-per-task=6\\n#SBATCH --wait-all-nodes=1\\n#SBATCH --job-name=open_clip\\n#SBATCH --account=ACCOUNT_NAME\\n#SBATCH --partition PARTITION_NAME\\n\\neval \\\"$(/path/to/conda/bin/conda shell.bash hook)\\\" # init conda\\nconda activate open_clip\\nexport CUDA_VISIBLE_DEVICES=0,1,2,3\\nexport MASTER_PORT=12802\\n\\nmaster_addr=$(scontrol show hostnames \\\"$SLURM_JOB_NODELIST\\\" | head -n 1)\\nexport MASTER_ADDR=$master_addr\\n\\ncd /shared/open_clip\\nexport PYTHONPATH=\\\"$PYTHONPATH:$PWD/src\\\"\\nsrun --cpu_bind=v --accel-bind=gn python -u src/training/main.py \\\\\\n    --save-frequency 1 \\\\\\n    --report-to tensorboard \\\\\\n    --train-data=\\\"/data/LAION-400M/{00000..41455}.tar\\\" \\\\\\n    --warmup 2000 \\\\\\n    --batch-size=256 \\\\\\n    --epochs=32 \\\\\\n    --workers=8 \\\\\\n    --model ViT-B-32 \\\\\\n    --name \\\"ViT-B-32-Vanilla\\\" \\\\\\n    --seed 0 \\\\\\n    --local-loss \\\\\\n    --gather-with-grad\\nResuming from a checkpoint:\\npython -m training.main \\\\\\n    --train-data=\\\"/path/to/train_data.csv\\\" \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --resume /path/to/checkpoints/epoch_K.pt\\nTraining CoCa:\\nTraining CoCa models is enabled through specifying a CoCa config using the --model parameter of the training script. Currently available configs are \\\"coca_base\\\", \\\"coca_ViT-B-32\\\", and \\\"coca_roberta-ViT-B-32\\\" (which uses RoBERTa as the text encoder). CoCa configs are different from CLIP configs because they have an additional \\\"multimodal_cfg\\\" component which specifies parameters for the multimodal text decoder. Here's an example from the coca_ViT-B-32 config:\\n\\\"multimodal_cfg\\\": {\\n\\t\\\"context_length\\\": 76,\\n\\t\\\"vocab_size\\\": 49408,\\n\\t\\\"width\\\": 512,\\n\\t\\\"heads\\\": 8,\\n\\t\\\"layers\\\": 12,\\n\\t\\\"latent_dim\\\": 512,\\n\\t\\\"attn_pooler_heads\\\": 8\\n}\\nCredit to lucidrains for initial code, gpucce for adapting the code to open_clip, and iejMac for training the models.\\nGenerating text with CoCa\\nimport open_clip\\nimport torch\\nfrom PIL import Image\\n\\nmodel, _, transform = open_clip.create_model_and_transforms(\\n  model_name=\\\"coca_ViT-L-14\\\",\\n  pretrained=\\\"mscoco_finetuned_laion2B-s13B-b90k\\\"\\n)\\n\\nim = Image.open(\\\"cat.jpg\\\").convert(\\\"RGB\\\")\\nim = transform(im).unsqueeze(0)\\n\\nwith torch.no_grad(), torch.cuda.amp.autocast():\\n  generated = model.generate(im)\\n\\nprint(open_clip.decode(generated[0]).split(\\\"<end_of_text>\\\")[0].replace(\\\"<start_of_text>\\\", \\\"\\\"))\\nSee also this [Coca Colab]\\nFine Tuning CoCa\\nTo fine-tune coca on mscoco, first create the dataset, one way is using a csvdataset and perhaps the simplest way to do it is using CLIP_benchmark which in turn uses pycocotools (that can be used also by itself).\\nfrom clip_benchmark.datasets.builder import build_dataset\\nimport pandas as pd\\nimport os\\n\\nroot_path = \\\"path/to/data/dir\\\" # set this to smth meaningful\\nds = build_dataset(\\\"mscoco_captions\\\", root=root_path, split=\\\"train\\\") # this downloads the dataset if it is not there already\\ncoco = ds.coco\\nimgs = coco.loadImgs(coco.getImgIds())\\nfuture_df = {\\\"filepath\\\":[], \\\"title\\\":[]}\\nfor img in imgs:\\n    caps = coco.imgToAnns[img[\\\"id\\\"]]\\n    for cap in caps:\\n        future_df[\\\"filepath\\\"].append(img[\\\"file_name\\\"])\\n        future_df[\\\"title\\\"].append(cap[\\\"caption\\\"])\\npd.DataFrame.from_dict(future_df).to_csv(\\n  os.path.join(root_path, \\\"train2014.csv\\\"), index=False, sep=\\\"\\\\t\\\"\\n)\\nThis should create a csv dataset that one can use to fine-tune coca with open_clip\\npython -m training.main \\\\\\n    --dataset-type \\\"csv\\\" \\\\\\n    --train-data \\\"path/to/data/dir/train2014.csv\\\" \\\\\\n    --warmup 1000 \\\\\\n    --batch-size 128 \\\\\\n    --lr 1e-5 \\\\\\n    --wd 0.1 \\\\\\n    --epochs 1 \\\\\\n    --workers 3 \\\\\\n    --model \\\"coca_ViT-L-14\\\" \\\\\\n    --report-to \\\"wandb\\\" \\\\\\n    --coca-contrastive-loss-weight 0 \\\\\\n    --coca-caption-loss-weight 1 \\\\\\n    --log-every-n-steps 100\\nThis is a general setting, open_clip has very parameters that can be set, python -m training.main --help should show them. The only relevant change compared to pre-training are the two arguments\\n--coca-contrastive-loss-weight 0\\n--coca-caption-loss-weight 1\\nwhich make the model only train the generative side.\\nTraining with pre-trained language models as text encoder:\\nIf you wish to use different language models as the text encoder for CLIP you can do so by using one of the Hugging Face model configs in src/open_clip/model_configs and passing in it's tokenizer as the --model and --hf-tokenizer-name parameters respectively. Currently we only support RoBERTa (\\\"test-roberta\\\" config), however adding new models should be trivial. You can also determine how many layers, from the end, to leave unfrozen with the --lock-text-unlocked-layers parameter. Here's an example command to train CLIP with the RoBERTa LM that has it's last 10 layers unfrozen:\\npython -m training.main \\\\\\n         --train-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00000..00329}.tar -\\\" \\\\\\n         --train-num-samples 3000000 \\\\\\n         --val-data=\\\"pipe:aws s3 cp s3://s-mas/cc3m/{00330..00331}.tar -\\\" \\\\\\n         --val-num-samples 10000 \\\\\\n         --dataset-type webdataset \\\\\\n         --batch-size 256 \\\\\\n         --warmup 2000 \\\\\\n         --epochs 10 \\\\\\n         --lr 5e-4 \\\\\\n         --precision amp \\\\\\n         --workers 6 \\\\\\n         --model \\\"roberta-ViT-B-32\\\" \\\\\\n         --lock-text \\\\\\n         --lock-text-unlocked-layers 10 \\\\\\n         --name \\\"10_unfrozen\\\" \\\\\\n         --report-to \\\"tensorboard\\\" \\\\\\nLoss Curves\\nWhen run on a machine with 8 GPUs the command should produce the following training curve for Conceptual Captions:\\n\\nMore detailed curves for Conceptual Captions are given at /docs/clip_conceptual_captions.md.\\nWhen training a RN50 on YFCC the same hyperparameters as above are used, with the exception of lr=5e-4 and epochs=32.\\nNote that to use another model, like ViT-B/32 or RN50x4 or RN50x16 or ViT-B/16, specify with --model RN50x4.\\nLogging\\nFor tensorboard logging, run:\\ntensorboard --logdir=logs/tensorboard/ --port=7777\\nFor wandb logging, we recommend looking at the step variable instead of Step, since the later was not properly set in earlier versions of this codebase.\\nFor older runs with models trained before #613, the Step variable should be ignored.\\nFor newer runs, after that PR, the two variables are the same.\\nEvaluation / Zero-Shot\\nWe recommend https://github.com/LAION-AI/CLIP_benchmark#how-to-use for systematic evaluation on 40 datasets.\\nEvaluating local checkpoint:\\npython -m training.main \\\\\\n    --val-data=\\\"/path/to/validation_data.csv\\\"  \\\\\\n    --model RN101 \\\\\\n    --pretrained /path/to/checkpoints/epoch_K.pt\\nEvaluating hosted pretrained checkpoint on ImageNet zero-shot prediction:\\npython -m training.main \\\\\\n    --imagenet-val /path/to/imagenet/validation \\\\\\n    --model ViT-B-32-quickgelu \\\\\\n    --pretrained laion400m_e32\\nModel distillation\\nYou can distill from a pre-trained by using --distill-model and --distill-pretrained to specify the model you'd like to distill from.\\nFor instance, to distill from OpenAI ViT-L/14 use --distill-model ViT-L-14 --distill-pretrained openai.\\nGradient accumulation\\nTo simulate larger batches use --accum-freq k. If per gpu batch size, --batch-size, is m, then the effective batch size will be k * m * num_gpus.\\nWhen increasing --accum-freq from its default of 1, samples/s will remain approximately constant (batch size will double, as will time-per-batch). It is recommended to use other features to reduce batch size such as --grad-checkpointing --local-loss --gather-with-grad before increasing --accum-freq. --accum-freq can be used in addition to these features.\\nInstead of 1 forward pass per example, there are now 2 forward passes per-example. However, the first is done with torch.no_grad.\\nThere is some additional GPU memory required --- the features and data from all m batches are stored in memory."}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 1, "id": 60, "domain": "Time-series", "task": "classification", "readme": "https://github.com/thuml/Time-Series-Library/blob/main/README.md", "path": "./", "arguments": {"task_name": "classification", "model": "MICN", "data": "UEA", "model_id": "EthanolConcentration", "patience": "10", "batch_size": "16", "train_epochs": "100"}, "prefix_code": "", "output": "python -u run.py \\\n  --task_name classification \\\n  --is_training 1 \\\n  --root_path ./dataset/EthanolConcentration/ \\\n  --model_id EthanolConcentration \\\n  --model MICN \\\n  --data UEA \\\n  --e_layers 3 \\\n  --batch_size 16 \\\n  --d_model 128 \\\n  --d_ff 256 \\\n  --top_k 3 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --train_epochs 100 \\\n  --c_out 3 \\\n  --patience 10", "instruction": "I have a classification task that I aim to perform utilizing the MICN model. In my project, I would like to ascertain its performance using the EthanolConcentration subset, which is part of the benchmark datasets from UEA. I'd like to set up, too, patience parameter to 10 time steps, along with assigning training epochs to 16 and the batch size to 100. Would you mind assisting me in writing this code?", "oracle_segmet": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 2, "id": 61, "domain": "Time-series", "task": "long term forecast", "readme": "https://github.com/thuml/Time-Series-Library/blob/main/README.md", "path": "./", "arguments": {"task_name": "long_term_forecast", "model": "Crossformer", "data": "weather", "pred_len": "96"}, "prefix_code": "", "output": "python -u run.py \\\n  --task_name long_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/weather/ \\\n  --data_path weather.csv \\\n  --model_id weather_96_96 \\\n  --model Crossformer \\\n  --data custom \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 48 \\\n  --pred_len 96 \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 21 \\\n  --dec_in 21 \\\n  --c_out 21 \\\n  --d_model 32 \\\n  --d_ff 32 \\\n  --top_k 5 \\\n  --des 'Exp' \\\n  --itr 1", "instruction": "As part of my project, I am intending to evaluate the performance of the Crossformer model that I have utilized for the task of long term forecast. The Weather is the benchmark dataset that I wish to utilize for this assessment. I am planning on setting the pred_len parameter to 96. Can you provide some guidance or sample code to assist me with this process?", "oracle_segmet": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 3, "id": 62, "domain": "Time-series", "task": "long term forecast", "readme": "https://github.com/thuml/Time-Series-Library/blob/main/README.md", "path": "./", "arguments": {"task_name": "long_term_forecast", "model": "DLinear", "data": "ETTh1", "pred_len": "720", "root_path": "./dataset/ETT-small/", "data_path": "ETTh1.csv"}, "prefix_code": "", "output": "python -u run.py \\\n  --task_name long_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/ETT-small/ \\\n  --data_path ETTh1.csv \\\n  --model_id ETTh1_96_720 \\\n  --model DLinear \\\n  --data ETTh1 \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 48 \\\n  --pred_len 720 \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 7 \\\n  --dec_in 7 \\\n  --c_out 7 \\\n  --des 'Exp' \\\n  --itr 1", "instruction": "In order to conduct a performance evaluation of your model DLinear for the long term forecast task, you're looking to use the benchmark dataset ETTh1 from the ETT benchmark. To proceed, set the prediction length to 720, and note that the root path to your dataset is ./dataset/ETT-small/ and the respective data path is ETTh1.csv. Could you help provide me with the suitable code sequence to perform this task without glitches?", "oracle_segmet": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 4, "id": 63, "domain": "Time-series", "task": "long term forecast", "readme": "https://github.com/thuml/Time-Series-Library/blob/main/README.md", "path": "./", "arguments": {"task_name": "long_term_forecast", "model": "PatchTST", "data": "weather", "pred_len": "720"}, "prefix_code": "", "output": "python -u run.py \\\n  --task_name long_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/weather/ \\\n  --data_path weather.csv \\\n  --model_id weather_96_720 \\\n  --model PatchTST \\\n  --data custom \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 48 \\\n  --pred_len 720 \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 21 \\\n  --dec_in 21 \\\n  --c_out 21 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --n_heads 4 \\\n  --batch_size 128 \\\n  --train_epochs 3", "instruction": "At the moment, I'm in the process of performance assessing my PatchTST model for a long_term_forecast task. I've decided to employ a benchmark dataset titled 'Weather' for the purpose, with the prediction length parameter being 720. Could you possibly help me to formulate the required coding solutions for executing this operation?", "oracle_segmet": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 5, "id": 64, "domain": "Time-series", "task": "anomaly detection", "readme": "https://github.com/thuml/Time-Series-Library/blob/main/README.md", "path": "./", "arguments": {"task_name": "anomaly_detection", "model": "Crossformer", "data": "MSL"}, "prefix_code": "", "output": "python -u run.py \\\n  --task_name anomaly_detection \\\n  --is_training 1 \\\n  --root_path ./dataset/MSL \\\n  --model_id MSL \\\n  --model Crossformer \\\n  --data MSL \\\n  --features M \\\n  --seq_len 100 \\\n  --pred_len 0 \\\n  --d_model 128 \\\n  --d_ff 128 \\\n  --e_layers 3 \\\n  --enc_in 55 \\\n  --c_out 55 \\\n  --anomaly_ratio 1 \\\n  --batch_size 128 \\\n  --train_epochs 10", "instruction": "I am attempting to use Crossformer model for the specific task of anomaly detection. MSL is the benchmark dataset that I will need to employ for this endeavor. Could you possibly assist me in the formulation of the necessary code segments to evaluate the performance of this model?", "oracle_segmet": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 6, "id": 65, "domain": "Time-series", "task": "short term forecast", "readme": "https://github.com/thuml/Time-Series-Library/blob/main/README.md", "path": "./", "arguments": {"task_name": "short_term_forecast", "model": "Crossformer", "data": "m4", "seasonal_patterns": "Daily"}, "prefix_code": "", "output": "python -u run.py \\\n  --task_name short_term_forecast \\\n  --is_training 1 \\\n  --root_path ./dataset/m4 \\\n  --seasonal_patterns 'Daily' \\\n  --model_id m4_Daily \\\n  --model Crossformer \\\n  --data m4 \\\n  --features M \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 1 \\\n  --dec_in 1 \\\n  --c_out 1 \\\n  --batch_size 16 \\\n  --d_model 16 \\\n  --d_ff 16 \\\n  --top_k 5 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --learning_rate 0.001 \\\n  --loss 'SMAPE'", "instruction": "Can you assist me in writing some code? I'm dealing with a short-term forecast task and I would like to evaluate the performance of my model, which is the Crossformer. I have decided to use the M4 benchmark dataset and I would like to set the seasonal patterns to Daily.", "oracle_segmet": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n"}
{"github_id": 8, "github": "https://github.com/thuml/Time-Series-Library", "repo_id": 7, "id": 66, "domain": "Time-series", "task": "imputation", "readme": "https://github.com/thuml/Time-Series-Library/blob/main/README.md", "path": "./", "arguments": {"task_name": "imputation", "model": "TimesNet", "data": "ETTh1", "mask_rate": "0.375"}, "prefix_code": "", "output": "python -u run.py \\\n  --task_name imputation \\\n  --is_training 1 \\\n  --root_path ./dataset/ETT-small/ \\\n  --data_path ETTh1.csv \\\n  --model_id ETTh1_mask_0.375 \\\n  --mask_rate 0.375 \\\n  --model TimesNet \\\n  --data ETTh1 \\\n  --features M \\\n  --seq_len 96 \\\n  --label_len 0 \\\n  --pred_len 0 \\\n  --e_layers 2 \\\n  --d_layers 1 \\\n  --factor 3 \\\n  --enc_in 7 \\\n  --dec_in 7 \\\n  --c_out 7 \\\n  --batch_size 16 \\\n  --d_model 16 \\\n  --d_ff 32 \\\n  --des 'Exp' \\\n  --itr 1 \\\n  --top_k 3 \\\n  --learning_rate 0.001", "instruction": "I'm looking to evaluate the performance of my TimesNet model for an imputation task. The benchmark dataset I intend to use is the ETTh1 subset of ETT, with a mask rate of 0.375. Could you assist me by guiding me through the coding process?", "oracle_segmet": "For convenience, execute the following command.\\n\\npip install -r requirements.txt\\n\\n\\nPrepare Data. You can obtain the well pre-processed datasets from [Google Drive] or\u00a0[Baidu Drive], Then place the downloaded data in the folder./dataset. Here is a summary of supported datasets.\\n\\n\\n\\n\\n\\nTrain and evaluate model. We provide the experiment scripts for all benchmarks under the folder ./scripts/. You can reproduce the experiment results as the following examples:\\n\\n# long-term forecast\\nbash ./scripts/long_term_forecast/ETT_script/TimesNet_ETTh1.sh\\n# short-term forecast\\nbash ./scripts/short_term_forecast/TimesNet_M4.sh\\n# imputation\\nbash ./scripts/imputation/ETT_script/TimesNet_ETTh1.sh\\n# anomaly detection\\nbash ./scripts/anomaly_detection/PSM/TimesNet.sh\\n# classification\\nbash ./scripts/classification/TimesNet.sh\\n\\n\\nDevelop your own model.\\n\\n\\nAdd the model file to the folder ./models. You can follow the ./models/Transformer.py.\\nInclude the newly added model in the Exp_Basic.model_dict of  ./exp/exp_basic.py.\\nCreate the corresponding scripts under the folder ./scripts.\\n\\nCitation\\nIf you find this repo useful, please cite our paper.\\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 1, "id": 67, "domain": "Attention Usage", "task": "attention layer", "readme": "https://github.com/xmu-xiaoma666/External-Attention-pytorch/blob/master/README_EN.md", "path": "./", "arguments": {"argument": "ViP", "argument2": "WeightedPermuteMLP"}, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.ViP import WeightedPermuteMLP\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(64,8,8,512)\nseg_dim=8\nvip=WeightedPermuteMLP(512,seg_dim)\nout=vip(input)\nprint(out.shape)\n\n", "instruction": "I'm planning to utilize the fighting-cv model to complete the attention layers for ViP Attention Usage. Could you provide me with some guidance on accomplishing this task?", "oracle_segmet": "from model.attention.ViP import WeightedPermuteMLP\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(64,8,8,512)\nseg_dim=8\nvip=WeightedPermuteMLP(512,seg_dim)\nout=vip(input)\nprint(out.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 2, "id": 68, "domain": "Attention Usage", "task": "attention layer", "readme": "https://github.com/xmu-xiaoma666/External-Attention-pytorch/blob/master/README_EN.md", "path": "./", "arguments": {"argument": "ParNetAttention"}, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.ParNetAttention import *\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(50,512,7,7)\n    pna = ParNetAttention(channel=512)\n    output=pna(input)\n    print(output.shape) #50,512,7,7\n    \n\n", "instruction": "I'm interested in learning to use the fighting-cv model to achieve completion of attention layers for ParNet Attention Usage. Can you assist by providing the necessary guide or advice?", "oracle_segmet": "from model.attention.ParNetAttention import *\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(50,512,7,7)\n    pna = ParNetAttention(channel=512)\n    output=pna(input)\n    print(output.shape) #50,512,7,7\n    \n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 3, "id": 69, "domain": "Attention Usage", "task": "attention layer", "readme": "https://github.com/xmu-xiaoma666/External-Attention-pytorch/blob/master/README_EN.md", "path": "./", "arguments": {"argument": "PolarizedSelfAttention", "argument2": "ParallelPolarizedSelfAttention", "argument3": "SequentialPolarizedSelfAttention"}, "prefix_code": "pip install fightingcv-attention", "output": "from model.attention.PolarizedSelfAttention import ParallelPolarizedSelfAttention,SequentialPolarizedSelfAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(1,512,7,7)\npsa = SequentialPolarizedSelfAttention(channel=512)\noutput=psa(input)\nprint(output.shape)\n", "instruction": "It is required to utilize the fighting-cv model to successfully complete the attention layers task for Polarized Self-Attention Usage. Can you provide a detailed explanation as well as code snippets on how to get this task done?", "oracle_segmet": "from model.attention.PolarizedSelfAttention import ParallelPolarizedSelfAttention,SequentialPolarizedSelfAttention\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\ninput=torch.randn(1,512,7,7)\npsa = SequentialPolarizedSelfAttention(channel=512)\noutput=psa(input)\nprint(output.shape)\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 4, "id": 70, "domain": "Attention Usage", "task": "backbone layer", "readme": "https://github.com/xmu-xiaoma666/External-Attention-pytorch/blob/master/README_EN.md", "path": "./", "arguments": {"argument": "HATNet"}, "prefix_code": "pip install fightingcv-attention", "output": "from model.backbone.HATNet import HATNet\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    hat = HATNet(dims=[48, 96, 240, 384], head_dim=48, expansions=[8, 8, 4, 4],\n  grid_sizes=[8, 7, 7, 1], ds_ratios=[8, 4, 2, 1], depths=[2, 2, 6, 3])\n    output=hat(input)\n    print(output.shape)\n\n", "instruction": "I'm interested in using the fighting-cv algorithm for constructing the backbone layers of the HATNet Usage project. Can you assist me in developing suitable code for this project?", "oracle_segmet": "from model.backbone.HATNet import HATNet\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nif __name__ == '__main__':\n    input=torch.randn(1,3,224,224)\n    hat = HATNet(dims=[48, 96, 240, 384], head_dim=48, expansions=[8, 8, 4, 4],\n  grid_sizes=[8, 7, 7, 1], ds_ratios=[8, 4, 2, 1], depths=[2, 2, 6, 3])\n    output=hat(input)\n    print(output.shape)\n\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 5, "id": 71, "domain": "Attention Usage", "task": "Attention layer", "readme": "https://github.com/xmu-xiaoma666/External-Attention-pytorch/blob/master/README_EN.md", "path": "./", "arguments": {"data": "(50,49,512)", "model": "AFT", "argument2": "AFT_FULL"}, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "import argparse\nfrom model.attention.AFT import AFT_FULL\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--n_epochs\", type=int, default=200, help=\"number of epochs of training\")\nparser.add_argument(\"--batch_size\", type=int, default=64, help=\"size of the batches\")\nparser.add_argument(\"--lr\", type=float, default=0.0002, help=\"adam: learning rate\")\nparser.add_argument(\"--b1\", type=float, default=0.5, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--b2\", type=float, default=0.999, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--n_cpu\", type=int, default=8, help=\"number of cpu threads to use during batch generation\")\nparser.add_argument(\"--latent_dim\", type=int, default=100, help=\"dimensionality of the latent space\")\nparser.add_argument(\"--n_classes\", type=int, default=10, help=\"number of classes for dataset\")\nparser.add_argument(\"--img_size\", type=int, default=32, help=\"size of each image dimension\")\nparser.add_argument(\"--channels\", type=int, default=1, help=\"number of image channels\")\nparser.add_argument(\"--sample_interval\", type=int, default=400, help=\"interval between image sampling\")\nopt = parser.parse_args()\n\ninput=torch.randn(50,49,512)\naft_full = AFT_FULL(d_model=512, n=49)\noutput=aft_full(input)\nprint(output.shape)", "instruction": "My input data shape is (50,49,512) and I intend to utilize it to complete the Attention layers task employing the AFT model via the fighting cv library. Could you assist me in crafting the appropriate code?", "oracle_segmet": " from model.attention.AFT import AFT_FULL\\nimport torch\\nfrom torch import nn\\nfrom torch.nn import functional as F\\n\\ninput=torch.randn(50,49,512)\\naft_full = AFT_FULL(d_model=512, n=49)\\noutput=aft_full(input)\\nprint(output.shape)\\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 6, "id": 72, "domain": "Attention Usage", "task": "Attention layer", "readme": "https://github.com/xmu-xiaoma666/External-Attention-pytorch/blob/master/README_EN.md", "path": "./", "arguments": {"data": "(50,49,512)", "model": "SimplifiedSelfAttention", "argument": "SimplifiedScaledDotProductAttention"}, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "import argparse\nimport torch\nfrom model.attention.SimplifiedSelfAttention import SimplifiedScaledDotProductAttention\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--n_epochs\", type=int, default=200, help=\"number of epochs of training\")\nparser.add_argument(\"--batch_size\", type=int, default=64, help=\"size of the batches\")\nparser.add_argument(\"--lr\", type=float, default=0.0002, help=\"adam: learning rate\")\nparser.add_argument(\"--b1\", type=float, default=0.5, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--b2\", type=float, default=0.999, help=\"adam: decay of first order momentum of gradient\")\nparser.add_argument(\"--n_cpu\", type=int, default=8, help=\"number of cpu threads to use during batch generation\")\nparser.add_argument(\"--latent_dim\", type=int, default=100, help=\"dimensionality of the latent space\")\nparser.add_argument(\"--n_classes\", type=int, default=10, help=\"number of classes for dataset\")\nparser.add_argument(\"--img_size\", type=int, default=32, help=\"size of each image dimension\")\nparser.add_argument(\"--channels\", type=int, default=1, help=\"number of image channels\")\nparser.add_argument(\"--sample_interval\", type=int, default=400, help=\"interval between image sampling\")\nopt = parser.parse_args()\n\ninput=torch.randn(50,49,512)\nssa = SimplifiedScaledDotProductAttention(d_model=512, h=8)\noutput=ssa(input,input,input)\nprint(output.shape)", "instruction": "I've got a dataset with size (50,49,512), and I'm planning to utilize the SimplifiedSelfAttention model to implement Attention layers through the fighting cv library. Could you assist me in composing the applicable code?", "oracle_segmet": " from model.attention.SimplifiedSelfAttention import SimplifiedScaledDotProductAttention\\nimport torch\\n\\ninput=torch.randn(50,49,512)\\nssa = SimplifiedScaledDotProductAttention(d_model=512, h=8)\\noutput=ssa(input,input,input)\\nprint(output.shape)\\n\\n"}
{"github_id": 9, "github": "https://github.com/xmu-xiaoma666/External-Attention-pytorch", "repo_id": 7, "id": 73, "domain": "Attention Usage", "task": "Attention layer", "readme": "https://github.com/xmu-xiaoma666/External-Attention-pytorch/blob/master/README_EN.md", "path": "./", "arguments": {"data": "(50,49,512)", "model": "ExternalAttention"}, "prefix_code": "git clone https://github.com/xmu-xiaoma666/External-Attention-pytorch.git\ncd External-Attention-pytorch", "output": "import argparse\nimport torch\nfrom model.attention.ExternalAttention import ExternalAttention\n\ninput_size = (50, 49, 512)\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--d_model\", type=int, default=512, help=\"dimensionality of the model\")\nparser.add_argument(\"--S\", type=int, default=8, help=\"number of attention heads\")\nopt = parser.parse_args()\n\ninput = torch.randn(*input_size)\nea = ExternalAttention(d_model=opt.d_model, S=opt.S)\noutput = ea(input)\nprint(output.shape)", "instruction": "I am in possession of a data input in the shape of (50,49,512). My intention is to deploy this within the realm of External Attention Usage. My aim is to successfully complete Attention layers using the fighting cv library. However, after accomplishing this, I would also want to know the output shape. May you kindly assist in crafting the necessary coding elements?", "oracle_segmet": " from model.attention.ExternalAttention import ExternalAttention\\nimport torch\\n\\ninput=torch.randn(50,49,512)\\nea = ExternalAttention(d_model=512,S=8)\\noutput=ea(input)\\nprint(output.shape)\\n\\n"}
